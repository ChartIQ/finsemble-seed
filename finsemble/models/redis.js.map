{"version":3,"file":"models/redis.js","sources":["webpack:///webpack/bootstrap 7b60fcd4987b5827910f?4535****","webpack:///./~/superagent/lib/is-object.js?9edd*","webpack:///src/common/routerTransport.js?3341**","webpack:///src/clients/logger.js?88c9**","webpack:///./~/superagent/lib/client.js?a54e*","webpack:///./~/component-emitter/index.js?ea2f*","webpack:///src/common/util.js?fdac**","webpack:///./~/superagent/lib/agent-base.js?ac4a*","webpack:///./~/superagent/lib/request-base.js?2071*","webpack:///./~/superagent/lib/response-base.js?25a2*","webpack:///./~/superagent/lib/utils.js?15bb*","webpack:///src/common/validate.js?76e7**","webpack:///src/services/storage/models/base.js","webpack:///src/clients/routerClientInstance.js?019c**","webpack:///src/services/storage/models/redis.js","webpack:///src/common/systemSettings.js?cdba**","webpack:///src/clients/routerClientConstructor.js?bb10**","webpack:///src/common/configUtil.js?3947**"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"http://localhost:3375/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 378);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7b60fcd4987b5827910f","'use strict';\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null !== obj && 'object' === typeof obj;\n}\n\nmodule.exports = isObject;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/superagent/lib/is-object.js\n// module id = 105\n// module chunks = 0 2 4","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n// This routerTransport module is shared between router clients and the router service.  It supports\n// the addition of new transports without any change to the router code. Each transport is\n// point-to-point between a router client and the router service (i.e. hub and spoke).  Each router\n// client can use a different transport (i.e. the router service connects to them all).\n\n\"use strict\";\nvar Utils = require(\"../common/util\");\nvar console = new Utils.Console(\"RouterTransport\"); // Finsemble console\n\n/**\n * @introduction\n * <h2>Router Transport</h2>\n * **Service-Level Module**.  Manages and contains the point-to-point transports (i.e. Layer 2) supported by Finsemble.\n * Each transport communicates betweew a Finsemble services or component (on one end) and the Finsemble router (on the other end).\n *\n * The OpenFinBus transport is used for cross-domain components (where SharedWorker fails).\n *\n * Requirements for adding a new transport:\n * 1) create new transport object with same interface provided by SharedWorkerTransport and OpenFinTransport in this file.\n * 2) call RouterTransport.addTransport() to make the transport available (see the bottom of this file)\n *\n * Integration into routerService.js is automatic.\n *\n * @namespace RouterTransport\n */\nvar RouterTransport = {\n\n\tactiveTransports: {},\n\n\t/**\n\t * Adds a new type of router transport to pass message between RouterClient and RouterService.\n\t *\n\t * @param {string} transportName identifies the new transport\n\t * @param {object} transportConstructor returns an instance of the new transport\n\t */\n\taddTransport: function (transportName, transportConstructor) {\n\t\tthis.activeTransports[transportName] = transportConstructor;\n\t\twindow.console.info(\"RouterTransport added: \" + transportName);\n\t},\n\n\t/**\n\t * Gets array of active transports\n\t *\n\t * @returns array transport names/identifier\n\t */\n\tgetActiveTransports: function () {\n\t\tvar transportNames = [];\n\t\tfor (var transportIdentifier in this.activeTransports) {\n\t\t\ttransportNames.push(transportIdentifier);\n\t\t}\n\t\treturn transportNames;\n\t},\n\n\t/**\n\t * Get default transport for event router -- this is the most reliable transport across all contexts\n\t *\n \t * @param {object} params parameters for transport\n\t * @param {any} incomingMessageHandler\n\t * @param {any} source\n\t * @param {any} destination\n\t * @returns the transport object\n\t */\n\tgetDefaultTransport: function (params, incomingMessageHandler, source, destination) {\n\t\treturn RouterTransport.getTransport(params, \"OpenFinBus\", incomingMessageHandler, source, destination);\n\t},\n\n\t/**\n\t * Get best client transport based on the run-time context. Will only return cross-domain transport if current context is inter-domain.\n\t *\n \t * @param {object} params parameters for transport\n\t * @param {any} incomingMessageHandler\n\t * @param {any} source\n\t * @param {any} destination\n\t * @returns the transport object\n\t */\n\tgetRecommendedTransport: function (params, incomingMessageHandler, source, destination) {\n\t\tvar newTransport; // return variable\n\n\t\t// Will tell you if the window is in an iframe or not (for future)\n\t\tfunction isInIframe() {\n\t\t\ttry {\n\t\t\t\treturn window.self !== window.top;\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// returns true if this window's location is in another domain\n\t\tfunction crossDomain() {\n\t\t\tvar parser = document.createElement('a');\n\t\t\tparser.href = params.routerDomainRoot;\n\n\t\t\tvar isSameHost = (window.location.hostname === parser.hostname);\n\n\t\t\tvar isSameProtocol = (window.location.protocol === parser.protocol);\n\n\t\t\tvar wport = (window.location.port === undefined) ? window.location.port : 80;\n\t\t\tvar pport = (parser.port === undefined) ? parser.port : 80;\n\t\t\tvar isSamePort = (wport === pport);\n\n\t\t\tvar isCrossDomain = params.forceRouterToOFB || !(isSameHost && isSamePort && isSameProtocol);\n\t\t\tconsole.debug(\"Transport crossDomain=\" + isCrossDomain + \" (\" + params.forceRouterToOFB + \":\" + isSameHost + \":\" + isSameProtocol + \":\" + isSamePort + \")\");\n\t\t\treturn isCrossDomain;\n\t\t}\n\n\t\t// returns name of the best transport for communicating with router service\n\t\tfunction recommendedTransportName() {\n\t\t\tvar recommendedName = \"SharedWorker\"; // default -- fast but doesn't work cross-domain\n\t\t\tif (crossDomain()) {\n\t\t\t\trecommendedName = \"OpenFinBus\"; // required for cross-domain event messaging between windows\n\t\t\t}\n\t\t\treturn recommendedName;\n\t\t}\n\n\t\tvar transportName = recommendedTransportName();\n\t\treturn RouterTransport.getTransport(params, transportName, incomingMessageHandler, source, destination);\n\t},\n\n\t/**\n\t * Get a specific transport by name. The transport must be in list of the active transports (i.e. previously added).\n\t *\n \t * @param {object} params parameters for transport\n\t * @param {any} transportName\n\t * @param {any} incomingMessageHandler\n\t * @param {any} source\n\t * @param {any} destination\n\t * @returns the transport object\n\t */\n\tgetTransport: function (params, transportName, incomingMessageHandler, source, destination) {\n\t\tvar self = this;\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tvar transportConstructor = self.activeTransports[transportName];\n\t\t\tif (transportConstructor) {\n\t\t\t\tvar newTransport = new transportConstructor(params, transportName, incomingMessageHandler, source, destination);\n\t\t\t\tresolve(newTransport);\n\t\t\t} else {\n\t\t\t\treject(\"unknown transport name: \" + transportName);\n\t\t\t}\n\t\t});\n\t}\n};\n\n//////////////////////////////////////////////////////////////\n// Below all transports are defined then added to active list\n//////////////////////////////////////////////////////////////\n\nvar RouterTransportImplementation = {}; // a convenience namespace for router-transport implementations\n\n/*\n * Implements the SharedWorker Transport.\n *\n * Required Functions (used by transport clients):\n * \t\tsend(eventMessage) -- transports the event\n * \t\tidentifier() -- returns transport name/identifier\n *\n * @param {object} params parameters for SharedWorker transport\n * @param {object} name the name the transport will be reference by\n * @param {any} parentMessageHandlerParm callback for incoming event\n * @param {any} source for the transport (e.g. \"RouterClient\" or \"RouterService\")\n */\nRouterTransportImplementation.SharedWorkerTransport = function (params, name, parentMessageHandlerParm, source) {\n\tvar parentMessageHandler;\n\tvar routerThread;\n\tvar transportName;\n\tvar console = new Utils.Console(\"SharedWorkerTransport.\" + source); // Finsemble console\n\n\n\t// receives incoming shared-worker messages then passes on to parent with correct \"wrapper\"\n\tfunction sharedWorkerMessageHandler(swMessage) {\n\t\tvar port = swMessage.data[0];\n\t\tvar eventMessage = swMessage.data[1];\n\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"port\": port };\n\t\tconsole.debug2(\"Incoming Transport\", incomingTransportInfo, \"Message\", eventMessage);\n\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\n\t}\n\n\t//required function for parent (i.e. routeClient or routeService)\n\tthis.send = function (transport, eventMessage) {\n\t\t// handle optional transport parm\n\t\tif (arguments.length === 1) {  // clients use just one parm -- eventMessage\n\t\t\teventMessage = arguments[0];\n\t\t\ttransport = null;\n\t\t\tconsole.debug2(\"Outgoing Transport\", transportName, \"Message\", eventMessage);\n\t\t} else { // router services uses both parameters\n\t\t\ttransport = arguments[0];\n\t\t\teventMessage = arguments[1];\n\t\t\tconsole.debug2(\"Outgoing Transport\", transport, \"Message\", eventMessage);\n\t\t}\n\t\ttry {\n\t\t\trouterThread.port.postMessage([transport, eventMessage]);\n\t\t}\n\t\tcatch (e) {\n\t\t\tconsole.error(\"routerThread post message failed: \" + JSON.stringify(e), \"Probable cause is sending illegal data type (e.g. function).\");\n\t\t}\n\t};\n\n\t//required function for parent (i.e. routeClient or routeService)\n\tthis.identifier = function () {\n\t\treturn transportName;\n\t};\n\n\tconsole.debug(\"SharedWorker \" + params.routerSharedWorker + \" Initializing: \" + source);\n\ttransportName = name;\n\tparentMessageHandler = parentMessageHandlerParm;\n\trouterThread = new SharedWorker(params.routerSharedWorker, { name: \"Finsemble\", credentials: \"included\" });\n\trouterThread.port.onmessage = sharedWorkerMessageHandler;\n\trouterThread.onerror = function (e) {\n\t\tconsole.error(\"RouteClient SharedWorker Error\" + JSON.stringify(e));\n\t};\n\trouterThread.port.start();\n\n\tif (source === \"RouterService\") {  // send first message though shared worker to identify router service\n\t\trouterThread.port.postMessage({ data: \"connect\", source: \"RouterService\" });\n\t}\n};\n\n/*\n * Implements the OpenFin Bus Transport.\n *\n * Required Functions (used by transport clients):\n * \t\tsend(event) -- transports the event\n * \t\tidentifier() -- returns transport name/identifier\n *\n * @param {object} params unused in OpenFin transport\n * @param {object} name the name the transport will be reference by\n * @param {any} parentMessageHandlerParm callback for incoming event\n * @param {any} source for the transport (e.g. \"RouterClient\" or \"RouterService\")\n * @param {any} destination for the transport (e.g. \"RouterService\" or \"RouterClient\" )\n */\nRouterTransportImplementation.OpenFinTransport = function (params, name, parentMessageHandlerParm, source, destination) {\n\tvar parentMessageHandler;\n\tvar transportName;\n\tvar console = new Utils.Console(\"OpenFinTransport.\" + source); // Finsemble console\n\tvar uuid = fin.desktop.Application.getCurrent().uuid;\n\n\t// receives incoming OpenFin bus messages then passes on to parent with correct \"wrapper\"\n\tfunction openFinMessageHandler(eventMessage, senderUuid, name) {\n\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"senderUuid\": senderUuid, \"name\": eventMessage.header.origin };\n\t\tconsole.debug2(\"Incoming Transport\", incomingTransportInfo, \"Message\", eventMessage);\n\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\n\t}\n\n\tfunction subscribeFailure(reason) {\n\t\tconsole.error(\"OpenFinBus Subscribe Failure: \" + reason);\n\t}\n\n\t//required function for the parent (i.e. routeClient or routeService)\n\tthis.send = function (transport, eventMessage) {\n\t\tvar destTopic;\n\n\t\t// handle optional transport parm\n\t\tif (arguments.length === 1) { // client use just one parameter - eventMessage\n\t\t\tdestTopic = destination;\n\t\t\teventMessage = arguments[0];\n\t\t} else { // router service uses both parameters\n\t\t\tdestTopic = transport.name;\n\t\t\teventMessage = arguments[1];\n\t\t}\n\n\t\tconsole.debug2(\"Outgoing Transport\", uuid, destTopic, \"Message\", eventMessage);\n\t\tfin.desktop.InterApplicationBus.publish(destTopic, eventMessage,\n\t\t\tfunction () { }, function (err) { });\n\t};\n\n\t//required function for the parent (i.e. routeClient or routeService)\n\tthis.identifier = function () {\n\t\treturn transportName;\n\t};\n\n\ttransportName = name;\n\tparentMessageHandler = parentMessageHandlerParm;\n\twindow.console.debug(\"OpenFinBus Initializing: \" + source);\n\tfin.desktop.InterApplicationBus.subscribe('*', source, openFinMessageHandler, null, subscribeFailure);\n};\n\n// add the transports to the available/active list\nRouterTransport.addTransport(\"SharedWorker\", RouterTransportImplementation.SharedWorkerTransport);\n\nRouterTransport.addTransport(\"OpenFinBus\", RouterTransportImplementation.OpenFinTransport);\n\nmodule.exports = RouterTransport;\n\n\n\n// WEBPACK FOOTER //\n// src/common/routerTransport.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\"use strict\";\n\nconst LOCAL_ONLY_DEFAULT = false; // if true all logging will default to local console; will be overwritten by LoggerService's registration response\n\n// capture everything at startup; will be filtered later as needed when LoggerService's registration response provides settings; overhead here is not too high\nvar DEFAULT_LOG_SETTING = { Error: true, Warn: true, Info: true, Log: true, Debug: true, Verbose: true, LocalOnly: LOCAL_ONLY_DEFAULT }; // if true captured for logger\nvar CONSOLE_DEFAULT_LOG_SETTING = { Error: true, Warn: true, Info: true, Log: true, Debug: true }; // if true then goes to console and captured for logger\n\nconst MAX_QUEUE_SIZE = 10 * 1000; // maximum logger queue size; plenty of space although shouldn't need much since continuely sending to logger if working correctly;\n\nvar Validate = require(\"../common/validate\"); // Finsemble args validator\nvar RouterClient; // wait till start to fill in\n\n/**\n * @introduction\n * <h2>Config Client</h2>\n *\n * This client provides run-time access to Finsemble's configuration. See [Understanding Finsemble's Configuration]{@tutorial understandingConfiguration} for a configuration overview.\n *\n * @hideConstructor true\n * @constructor\n */\nvar Logger = function () {\n\tvar self = this;\n\tvar isRegistering = false; // if registering start\n\tvar isRegistered = false; // if registering complete\n\tvar isActiveTransmitTimer = false;\n\tvar loggerConsole = self;\n\tvar updatedLogState;\n\tvar isStarted = false;\n\tvar isReady = false;\n\tvar calibratedTimeStampOffset = 0;\n\tvar newCalibratedTimeStampOffset;\n\n\tvar loggerQueue = [];\n\tvar warningIssued = false; // used to limit warning messages\n\n\tvar loggerClientName = window.name;\n\tif (window.top !== window) { // amend name if iFrame\n\t\tloggerClientName += \".Frame\";\n\t}\n\tvar clientChannel = \"finsemble.logger.client.\" + loggerClientName;\n\n\tconst CATEGORIES = [\"console\", \"dev\", \"system\", \"perf\"];\n\n\tvar initialLogState = {}; // will be updated on registration with central console, but capture everything until then\n\tinitialLogState.console = CONSOLE_DEFAULT_LOG_SETTING;\n\tinitialLogState.dev = DEFAULT_LOG_SETTING;\n\tinitialLogState.system = DEFAULT_LOG_SETTING;\n\tinitialLogState.perf = DEFAULT_LOG_SETTING;\n\n\tvar currentLogState = initialLogState;\n\n\tfunction LoggerMessage(category, type, data) {\n\t\tthis.category = category;\n\t\tthis.logClientName = loggerClientName;\n\t\tthis.logType = type;\n\t\tthis.logData = data;\n\t\tthis.logTimestamp = window.performance.timing.navigationStart + window.performance.now() + calibratedTimeStampOffset;\n\t}\n\n\tfunction addToQueue(message) {\n\t\tif (loggerQueue.length < MAX_QUEUE_SIZE) {\n\t\t\tloggerQueue.push(message);\n\t\t} else {\n\t\t\tif (!warningIssued) {\n\t\t\t\tconsole.warn(\"Logging Queue Overflowed!\", loggerQueue);\n\t\t\t\twarningIssued = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if log state changes then update queue based on that data (e.g. if no longer logging debug messages, then remove them from the queue)\n\tfunction updateQueueBasedOnState(calibrateTimeFlag) {\n\t\tloggerConsole.system.debug(\"Logger updateQueueBasedOnState\", calibrateTimeFlag, calibratedTimeStampOffset, \"QUEUE LENGTH\", loggerQueue.length, currentLogState);\n\t\tvar newQueue = [];\n\t\tfor (var i = 0, length = loggerQueue.length; i < length; i++) {\n\t\t\tif (currentLogState[loggerQueue[i].category][loggerQueue[i].logType] && !currentLogState[loggerQueue[i].category].LocalOnly) {\n\t\t\t\tif (calibrateTimeFlag) {\n\t\t\t\t\tloggerQueue[i].logTimestamp += calibratedTimeStampOffset; // if flag set then timestamp hasn't been adjusted yet by calibrated offset time\n\t\t\t\t}\n\t\t\t\tnewQueue.push(loggerQueue[i]);\n\t\t\t} else { // only now know LocalOnly for messages, so print those queued out otherwise they will be lost\n\t\t\t\tif (currentLogState[loggerQueue[i].category][loggerQueue[i].logType] && currentLogState[loggerQueue[i].category].LocalOnly) {\n\t\t\t\t\tlet msg = loggerQueue[i];\n\t\t\t\t\tconsole.log(msg.category, msg.logType, msg.logTimestamp - window.performance.timing.navigationStart, msg.logData, \"(Previously queued!)\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tloggerQueue = newQueue;\n\t}\n\n\tthis.setClientName = function (name) {\n\t\tloggerClientName = name;\n\t};\n\n\tthis.getClientName = function (name) {\n\t\treturn loggerClientName;\n\t};\n\n\tthis.clearMessageList = function () {\n\t\tloggerQueue = [];\n\t};\n\n\tfunction setLogState(state, calibrateTimeFlag) {\n\t\tcurrentLogState = state;\n\t\tupdateQueueBasedOnState(calibrateTimeFlag);\n\t}\n\n\t// returns a stack-trace substring\n\tfunction oldtraceString() {\n\t\tvar tString = new Error().stack;\n\t\treturn tString;\n\t}\n\n\tfunction traceString() {\n\t\tfunction getPosition(string, subString, index) {\n\t\t\treturn string.split(subString, index).join(subString).length;\n\t\t}\n\n\t\tfunction getErrorObject() {\n\t\t\ttry { throw Error(\"\"); } catch (err) { return err; }\n\t\t}\n\t\tvar stack = getErrorObject().stack;\n\t\tvar position = getPosition(stack, \"\\n\", 4);\n\t\tvar tString = stack.substring(position); // strip off irrelevant part of stack\n\t\tvar final = \"Log Stack: \\n\" + tString.substr(1); // insert description\n\t\treturn final;\n\t}\n\n\t// save original console functions since going to wrap/redefine each\n\tvar orignalConsoleError = console.error;\n\tvar orignalConsoleWarn = console.warn;\n\tvar orignalConsoleInfo = console.info;\n\tvar orignalConsoleLog = console.log;\n\tvar orignalConsoleDebug = console.debug;\n\n\t// expose original console in case client still wants to directly access\n\tconsole.original = {};\n\tconsole.original.error = console.error;\n\tconsole.original.warn = console.warn;\n\tconsole.original.info = console.info;\n\tconsole.original.log = console.log;\n\tconsole.original.debug = console.debug;\n\n\t// option to restore console (i.e. use Logger without overriding console) -- not yet tested\n\tthis.restoreConsole = function () {\n\t\tconsole.error = orignalConsoleError;\n\t\tconsole.warn = orignalConsoleWarn;\n\t\tconsole.info = orignalConsoleInfo;\n\t\tconsole.log = orignalConsoleLog;\n\t\tconsole.debug = orignalConsoleDebug;\n\t};\n\n\tfunction formatAndQueueMessage(category, type, args) {\n\t\tvar message;\n\t\ttry {\n\t\t\tmessage = new LoggerMessage(category, type, JSON.stringify(args));\n\t\t} catch (err) {\n\t\t\targs.splice(0, args.length); // clear but don't redefine since must return updated value\n\t\t\targs.push(traceString());\n\t\t\tmessage = new LoggerMessage(category, type, \"*** Logging Error: \" + JSON.stringify(args));\n\t\t}\n\n\t\taddToQueue(message);\n\n\t\tif (isRegistered) {\n\t\t\tif (!isActiveTransmitTimer) { // since log message added to queue, only set timer to transmit log if not already set\n\t\t\t\tif (loggerClientName === \"routerService\") {\n\t\t\t\t\tsetTimeout(transmitAndClearQueue, 100); // HERE is the interval for transmitting queued messages to the logger service\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(transmitAndClearQueue, 250); // HERE is the interval for transmitting queued messages to the logger service\n\t\t\t\t}\n\t\t\t\tisActiveTransmitTimer = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction transmitAndClearQueue() {\n\t\tRouterClient.transmit(\"logger.service.logMessages\", loggerQueue);\n\t\tloggerConsole.clearMessageList();\n\t\tisActiveTransmitTimer = false; // flag for supporting log transmit only when there is something in the log queue\n\t}\n\n\tfunction outputToConsole(consoleType, args) {\n\t\ttry {\n\t\t\tconsoleType.apply(console, args);\n\t\t} catch (err) {\n\t\t\targs = [];\n\t\t\targs.push(traceString());\n\t\t\tmessage = new LoggerMessage(category, type, \"*** Console Logging Error: \" + JSON.stringify(args));\n\t\t}\n\t}\n\n\t// wrap main console functions\n\tconsole.error = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleError, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Error && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Error\", args);\n\t\t}\n\t};\n\n\tconsole.warn = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleWarn, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Warn && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Warn\", args);\n\t\t}\n\t};\n\n\tconsole.info = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleInfo, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Info && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Info\", args);\n\t\t}\n\t};\n\n\tconsole.log = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleLog, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Log && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Log\", args);\n\t\t}\n\t};\n\n\tconsole.debug = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleDebug, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Debug && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Debug\", args);\n\t\t}\n\t};\n\n\t// dev mode functions\n\tthis.error = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\n\t\tif (currentLogState.dev.Error && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Error\", args);\n\t\t}\n\n\t\targs.unshift(\"dev error (\" + window.performance.now() + \"):\");\n\t\toutputToConsole(orignalConsoleError, args);\n\t};\n\n\tthis.warn = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Warn && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Warn\", args);\n\t\t}\n\t\tif (currentLogState.dev.Warn && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev warn (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleWarn, args);\n\t\t}\n\t};\n\n\tthis.info = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Info && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Info\", args);\n\t\t}\n\t\tif (currentLogState.dev.Info && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev info (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleInfo, args);\n\t\t}\n\t};\n\n\tthis.log = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Log && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Log\", args);\n\t\t}\n\t\tif (currentLogState.dev.Log && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev log (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleLog, args);\n\t\t}\n\t};\n\n\tthis.debug = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Debug && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Debug\", args);\n\t\t}\n\t\tif (currentLogState.dev.Debug && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev debug (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\tthis.verbose = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Verbose && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Verbose\", args);\n\t\t}\n\t\tif (currentLogState.dev.Verbose && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev verbose (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\t// system mode functions\n\tthis.system = {};\n\tthis.system.error = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\n\t\tif (currentLogState.system.Error && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Error\", args);\n\t\t}\n\n\t\targs.unshift(\"system error (\" + window.performance.now() + \"):\");\n\t\toutputToConsole(orignalConsoleError, args);\n\t};\n\n\tthis.system.warn = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Warn && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Warn\", args);\n\t\t}\n\t\tif (currentLogState.system.Warn && currentLogState.system.LocalOnly) {\n\t\t\targs.unshift(\"system warn (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleWarn, args);\n\t\t}\n\t};\n\n\tthis.system.info = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Info && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Info\", args);\n\t\t}\n\t\tif (currentLogState.system.Info && currentLogState.system.LocalOnly) {\n\t\t\targs.unshift(\"system info (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleInfo, args);\n\t\t}\n\t};\n\n\tthis.system.log = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Log && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Log\", args);\n\t\t}\n\t\tif (currentLogState.system.Log && currentLogState.system.LocalOnly) {\n\t\t\targs.unshift(\"system log (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleLog, args);\n\t\t}\n\t};\n\n\tthis.system.debug = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Debug && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Debug\", args);\n\t\t}\n\t\tif (currentLogState.system.Debug && currentLogState.system.LocalOnly) {\n\t\t\targs.unshift(\"system debug (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\tthis.system.verbose = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Verbose && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Verbose\", args);\n\t\t}\n\t\tif (currentLogState.system.Verbose && currentLogState.system.LocalOnly) {\n\t\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\t\targs.unshift(\"system log (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\t// performance mode functions\n\tthis.perf = {};\n\tthis.perf.error = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\n\t\tif (currentLogState.perf.Error && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Error\", args);\n\t\t}\n\n\t\targs.unshift(\"perf error (\" + window.performance.now() + \"):\");\n\t\toutputToConsole(orignalConsoleError, args);\n\t};\n\n\tthis.perf.warn = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Warn && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Warn\", args);\n\t\t}\n\t\tif (currentLogState.perf.Warn && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf warn (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleWarn, args);\n\t\t}\n\t};\n\n\tthis.perf.info = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Info && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Info\", args);\n\t\t}\n\t\tif (currentLogState.perf.Info && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf info (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleInfo, args);\n\t\t}\n\t};\n\n\tthis.perf.log = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Log && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Log\", args);\n\t\t}\n\t\tif (currentLogState.perf.Log && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf log (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleLog, args);\n\t\t}\n\t};\n\n\tthis.perf.debug = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Debug && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Debug\", args);\n\t\t}\n\t\tif (currentLogState.perf.Debug && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf debug (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\tthis.perf.verbose = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Verbose && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Verbose\", args);\n\t\t}\n\t\tif (currentLogState.perf.Verbose && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf verbose (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\tfunction registerClient() {\n\t\tloggerConsole.system.debug(\"logger.service.registering\", loggerClientName);\n\t\tif (!LOCAL_ONLY_DEFAULT) {\n\t\t\tRouterClient.query(\"logger.service.register\", { clientName: loggerClientName, clientChannel }, function (error, queryMessage) {\n\t\t\t\tif (error) { // for some very early clients the logger may not be ready yet, so retry after a small wait\n\t\t\t\t\tsetTimeout(registerClient, 750);\n\t\t\t\t} else {\n\t\t\t\t\tisRegistered = true;\n\t\t\t\t\tloggerConsole.system.debug(\"logger.service.register response\", queryMessage.data);\n\t\t\t\t\tupdatedLogState = queryMessage.data;\n\t\t\t\t\tif (loggerClientName !== \"routerService\") {\n\t\t\t\t\t\tcalibratedTimeStampOffset = newCalibratedTimeStampOffset; // from now the real offset time will be used for all timestamps\n\t\t\t\t\t\tsetLogState(updatedLogState, true); // true indicates must adjust already queued timestamps by the new offset time\n\t\t\t\t\t} else { // router services doesn't need to calibrate time since it is the reference time\n\t\t\t\t\t\tsetLogState(updatedLogState, false);\n\t\t\t\t\t}\n\t\t\t\t\tformatAndQueueMessage(\"system\", \"Info\", [\"Logger Registered\"]);\n\t\t\t\t\ttransmitAndClearQueue();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tRouterClient.addListener(clientChannel, function (error, message) {\n\t\t\tloggerConsole.system.debug(\"logger.client.setLogState\", message.data);\n\t\t\tupdatedLogState = message.data;\n\t\t\tsetLogState(updatedLogState, false);\n\t\t});\n\t}\n\n\tfunction unregisterClient() {\n\t\tloggerConsole.system.debug(\"logger.service.unregister\", loggerClientName);\n\t\ttransmitAndClearQueue(); // send any message currently in the log queue\n\t\tRouterClient.query(\"logger.service.unregister\", { clientName: loggerClientName }, function () { });\n\t}\n\n\tfunction registerOnceWhenStarted() {\n\t\tif (!isRegistering) {\n\t\t\tregisterClient();\n\t\t\twindow.addEventListener(\"beforeunload\", unregisterClient);\n\t\t\tisRegistering = true;\n\t\t}\n\t}\n\n\tthis.isLogMessage = function (channel) {\n\t\treturn (channel === \"logger.service.logMessages\");\n\t};\n\n\tthis.start = function () {\n\t\tRouterClient = require(\"./routerClientInstance\");\n\t\tRouterClient.onReady(function () {\n\t\t\tloggerConsole.system.debug(\"Logger onReady\", loggerClientName);\n\t\t\t// timer calibration must be done so the messages will be correctly sorted in the central logger;\n\t\t\t// this is necessary because there is timer driff between windows --- this appears to be a Chromium\n\t\t\t// bug we have to work around it.  The timeOffset value adjusts the time using the routerService's\n\t\t\t// time as a central reference point.\n\t\t\tRouterClient.calibrateTimeWithRouterService(function (timeOffset) {\n\t\t\t\tnewCalibratedTimeStampOffset = timeOffset;\n\t\t\t\tregisterOnceWhenStarted();\n\t\t\t});\n\t\t});\n\t};\n};\n\nvar logger = new Logger();\n\nmodule.exports = logger;\n\n\n\n// WEBPACK FOOTER //\n// src/clients/logger.js","/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n  root = this;\n}\n\nvar Emitter = require('component-emitter');\nvar RequestBase = require('./request-base');\nvar isObject = require('./is-object');\nvar ResponseBase = require('./response-base');\nvar Agent = require('./agent-base');\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Expose `request`.\n */\n\nvar request = exports = module.exports = function(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new exports.Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new exports.Request('GET', method);\n  }\n\n  return new exports.Request(method, url);\n}\n\nexports.Request = Request;\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  throw Error(\"Browser-only version of superagent could not find XHR\");\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    pushEncodedKeyValuePair(pairs, key, obj[key]);\n  }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (val != null) {\n    if (Array.isArray(val)) {\n      val.forEach(function(v) {\n        pushEncodedKeyValuePair(pairs, key, v);\n      });\n    } else if (isObject(val)) {\n      for(var subkey in val) {\n        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\n      }\n    } else {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(val));\n    }\n  } else if (val === null) {\n    pairs.push(encodeURIComponent(key));\n  }\n}\n\n/**\n * Expose serialization method.\n */\n\nrequest.serializeObject = serialize;\n\n/**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var pair;\n  var pos;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    pos = pair.indexOf('=');\n    if (pos == -1) {\n      obj[decodeURIComponent(pair)] = '';\n    } else {\n      obj[decodeURIComponent(pair.slice(0, pos))] =\n        decodeURIComponent(pair.slice(pos + 1));\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'text/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\nrequest.serialize = {\n  'application/x-www-form-urlencoded': serialize,\n  'application/json': JSON.stringify,\n};\n\n/**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse,\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    if (index === -1) { // could be empty line, just skip it\n      continue;\n    }\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  return /[\\/+]json\\b/.test(mime);\n}\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req) {\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  var status = this.xhr.status;\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n  this._setStatusProperties(status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this._setHeaderProperties(this.header);\n\n  if (null === this.text && req._responseType) {\n    this.body = this.xhr.response;\n  } else {\n    this.body = this.req.method != 'HEAD'\n      ? this._parseBody(this.text ? this.text : this.xhr.response)\n      : null;\n  }\n}\n\nResponseBase(Response.prototype);\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype._parseBody = function(str) {\n  var parse = request.parse[this.type];\n  if (this.req._parser) {\n    return this.req._parser(this, str);\n  }\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      if (self.xhr) {\n        // ie9 doesn't have 'response' property\n        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;\n        // issue #876: return the http status code if the response parsing fails\n        err.status = self.xhr.status ? self.xhr.status : null;\n        err.statusCode = err.status; // backwards-compat only\n      } else {\n        err.rawResponse = null;\n        err.status = null;\n      }\n\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    var new_err;\n    try {\n      if (!self._isResponseOK(res)) {\n        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n      }\n    } catch(custom_err) {\n      new_err = custom_err; // ok() callback can throw\n    }\n\n    // #1000 don't catch errors from the callback to avoid double calling it\n    if (new_err) {\n      new_err.original = err;\n      new_err.response = res;\n      new_err.status = res.status;\n      self.callback(new_err, res);\n    } else {\n      self.callback(null, res);\n    }\n  });\n}\n\n/**\n * Mixin `Emitter` and `RequestBase`.\n */\n\nEmitter(Request.prototype);\nRequestBase(Request.prototype);\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} [pass] optional in case of using 'bearer' as type\n * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (1 === arguments.length) pass = '';\n  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options\n    options = pass;\n    pass = '';\n  }\n  if (!options) {\n    options = {\n      type: 'function' === typeof btoa ? 'basic' : 'auto',\n    };\n  }\n\n  var encoder = function(string) {\n    if ('function' === typeof btoa) {\n      return btoa(string);\n    }\n    throw new Error('Cannot use basic auth, btoa is not a function');\n  };\n\n  return this._auth(user, pass, options, encoder);\n};\n\n/**\n * Add query-string `val`.\n *\n * Examples:\n *\n *   request.get('/shoes')\n *     .query('size=10')\n *     .query({ color: 'blue' })\n *\n * @param {Object|String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `options` (or filename).\n *\n * ``` js\n * request.post('/upload')\n *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String|Object} options\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, options){\n  if (file) {\n    if (this._data) {\n      throw Error(\"superagent can't mix .send() and .attach()\");\n    }\n\n    this._getFormData().append(field, file, options || file.name);\n  }\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  if (this._shouldRetry(err, res)) {\n    return this._retry();\n  }\n\n  var fn = this._callback;\n  this.clearTimeout();\n\n  if (err) {\n    if (this._maxRetries) err.retries = this._retries - 1;\n    this.emit('error', err);\n  }\n\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n// This only warns, because the request is still likely to work\nRequest.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){\n  console.warn(\"This is not supported in browser version of superagent\");\n  return this;\n};\n\n// This throws, because it can't send/receive data as expected\nRequest.prototype.pipe = Request.prototype.write = function(){\n  throw Error(\"Streaming is not supported in browser version of superagent\");\n};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nRequest.prototype._isHost = function _isHost(obj) {\n  // Native objects stringify to [object File], [object Blob], [object FormData], etc.\n  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';\n}\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  if (this._endCalled) {\n    console.warn(\"Warning: .end() was called twice. This is not supported in superagent\");\n  }\n  this._endCalled = true;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // querystring\n  this._finalizeQueryString();\n\n  return this._end();\n};\n\nRequest.prototype._end = function() {\n  var self = this;\n  var xhr = (this.xhr = request.getXHR());\n  var data = this._formData || this._data;\n\n  this._setTimeouts();\n\n  // state change\n  xhr.onreadystatechange = function(){\n    var readyState = xhr.readyState;\n    if (readyState >= 2 && self._responseTimeoutTimer) {\n      clearTimeout(self._responseTimeoutTimer);\n    }\n    if (4 != readyState) {\n      return;\n    }\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (!status) {\n      if (self.timedout || self._aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(direction, e) {\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = direction;\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    try {\n      xhr.onprogress = handleProgress.bind(null, 'download');\n      if (xhr.upload) {\n        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\n      }\n    } catch(e) {\n      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n      // Reported here:\n      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n    }\n  }\n\n  // initiate request\n  try {\n    if (this.username && this.password) {\n      xhr.open(this.method, this.url, true, this.username, this.password);\n    } else {\n      xhr.open(this.method, this.url, true);\n    }\n  } catch (err) {\n    // see #1149\n    return this.callback(err);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n    // serialize stuff\n    var contentType = this._header['content-type'];\n    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) {\n      serialize = request.serialize['application/json'];\n    }\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n\n    if (this.header.hasOwnProperty(field))\n      xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\nrequest.agent = function() {\n  return new Agent();\n};\n\n[\"GET\", \"POST\", \"OPTIONS\", \"PATCH\", \"PUT\", \"DELETE\"].forEach(function(method) {\n  Agent.prototype[method.toLowerCase()] = function(url, fn) {\n    var req = new request.Request(method, url);\n    this._setDefaults(req);\n    if (fn) {\n      req.end(fn);\n    }\n    return req;\n  };\n});\n\nAgent.prototype.del = Agent.prototype['delete'];\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn) {\n  var req = request('GET', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn) {\n  var req = request('HEAD', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * OPTIONS query to `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.options = function(url, data, fn) {\n  var req = request('OPTIONS', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nfunction del(url, data, fn) {\n  var req = request('DELETE', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n}\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn) {\n  var req = request('PATCH', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn) {\n  var req = request('POST', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn) {\n  var req = request('PUT', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/superagent/lib/client.js\n// module id = 120\n// module chunks = 0 2 4","\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/component-emitter/index.js\n// module id = 122\n// module chunks = 0 2 4","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\nvar SystemSettings = require(\"../common/systemSettings\");\nvar Logger = require('../clients/logger');\nmodule.exports = {\n\t/**\n\t * Gets the openfin version in object form.\n\t */\n\tgetOpenfinVersion: function (cb) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfin.desktop.System.getVersion((ver) => {\n\t\t\t\tlet verArr = ver.split('.').map(Number);\n\t\t\t\tlet versionObject = {\n\t\t\t\t\tmajor: verArr[0],\n\t\t\t\t\tchromium: verArr[1],\n\t\t\t\t\tminor: verArr[2],\n\t\t\t\t\tpatch: verArr[3]\n\t\t\t\t};\n\t\t\t\tconsole.log(versionObject);\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(versionObject);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(versionObject);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\t/**\n\t * Given a function _that returns a value_, this method will return a thenable object.\n\t * **NOTE** This will not work if your function doesn't return something.\n\t *  <example>\n\t *\t\tfunction myFunc(){\n\t\t\t\tconsole.log('I promise that this is not a promise.');\n\t\t\t }\n\t\tlet myPromise = util.castToPromise(myFunc);\n\t\tmyPromise().then(doSomethingElse);\n\t\t</example>\n\n\t */\n\tcastToPromise: function (f) {\n\t\treturn function () {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t//Calls f, checks to see if the returned object has a `then` method. if not, it will resolve the result from the intiial function.\n\t\t\t\tconst result = f.apply(null, Array.from(arguments));\n\t\t\t\ttry {\n\t\t\t\t\treturn result.then(resolve, reject);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof TypeError) {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t},\n\t/**\n\t * @introduction\n\t * <h2>Finsemble Utility Functions</h2>\n\t * @private\n\t * @class Utils\n\t */\n\n\tisPercentage: function (val) {\n\t\tif (typeof (val) !== \"string\") {\n\t\t\treturn false;\n\t\t}\n\t\treturn val.indexOf(\"%\") !== -1;\n\t},\n\n\tretrieveMonitorDimensions: function (callback) {\n\t\tvar dims = {};\n\t\tvar b = {};\n\t\tthis.getMonitorInfo().then(function (monitorInfo) {\n\t\t\tvar availableMonitors = [monitorInfo.primaryMonitor].concat(monitorInfo.nonPrimaryMonitors);\n\t\t\tfin.desktop.Window.getCurrent().getBounds(function (bounds) {\n\t\t\t\tdims.defaultLeft = bounds.left;\n\t\t\t\tdims.defaultTop = bounds.top;\n\t\t\t\tb = bounds;\n\t\t\t\tfindMonitor();\n\t\t\t});\n\t\t\tfunction findMonitor() {\n\t\t\t\tfor (var i = 0; i < availableMonitors.length; i++) {\n\t\t\t\t\tvar monitor = availableMonitors[i].availableRect;\n\n\t\t\t\t\tmonitor.width = monitor.right - monitor.left;\n\t\t\t\t\tmonitor.height = monitor.bottom - monitor.top;\n\t\t\t\t\tif (dims.defaultLeft >= monitor.left && dims.defaultLeft < monitor.right) {\n\t\t\t\t\t\tdims.monitorDimensions = monitor;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(null, dims);\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t},\n\n\t/**\n * finsemble console for displaying diagnostic messages (a transparent replacement for window.top.console)\n * @param {string} name prefix for all console output\n * @memberof Utils\n * @constructor\n */\n\tConsole: function (name) {\n\n\t\tvar consoleName;\n\n\t\t// returns a trace substring\n\t\t// The \"sub\" parameter indicates function to start displaying trace from (i.e. truncate trace previous to this function)\n\t\tfunction traceString(sub) {\n\t\t\tfunction getErrorObject() {\n\t\t\t\ttry { throw Error(''); } catch (err) { return err; }\n\t\t\t}\n\t\t\tvar tString = getErrorObject().stack;\n\t\t\ttString = tString.substring(tString.indexOf(\"at \" + sub) - 5); // extra 5 chars to align formating\n\t\t\treturn tString;\n\t\t}\n\n\t\t/**\n\t\t * Pass through function for console.error, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 1\n\t\t *\n\t\t */\n\t\tthis.error = function () {\n\t\t\tvar myLevel = 1;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Error: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = traceString(\"error\") + \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.error.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function for console.warn, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 2\n\t\t *\n\t\t */\n\t\tthis.warn = function () {\n\t\t\tvar myLevel = 2;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Warn: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = traceString(\"warn\") + \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.warn.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function for console.info, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 3\n\t\t *\n\t\t */\n\t\tthis.info = function () {\n\t\t\tvar myLevel = 3;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Info: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.info.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function for console.log (but redirected to console.info), with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 3\n\t\t *\n\t\t */\n\t\tthis.log = function () {\n\t\t\tvar myLevel = 3;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Log: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.info.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function for console.debug, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 4\n\t\t *\n\t\t */\n\t\tthis.debug = function () {\n\t\t\tvar myLevel = 4;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Debug: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.debug.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 5\n\t\t *\n\t\t */\n\t\tthis.debug2 = function () {\n\t\t\tvar myLevel = 5;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Debug2: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.debug.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 6\n\t\t *\n\t\t */\n\t\tthis.debug3 = function () {\n\t\t\tvar myLevel = 6;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Debug3: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.debug.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 7\n\t\t *\n\t\t */\n\t\tthis.debug4 = function () {\n\t\t\tvar myLevel = 7;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Debug4: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.debug.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\tconsoleName = name;\n\t\tif (window.top !== window) {\n\t\t\tconsoleName += ' Frame';\n\t\t}\n\t},\n\n\t/**\n\t * @param {any} name\n\t * @param {any} payload\n\t * @memberof Utils\n\t */\n\tmsgWrapper: function (name, payload) {\n\t\tthis.name = name;\n\t\tthis.payload = payload;\n\t},\n\n\tmonitorInfo: null,\n\t/**\n\t * returns monitor infor\n\t *\n\t * @param {any} force\n\t * @returns object\n\t */\n\tgetMonitorInfo: function (force) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\n\t\t\t\tconsole.debug(\"getMonitorInfo\");\n\t\t\t\tmodule.exports.monitorInfo = monitorInfo;\n\t\t\t\tresolve(monitorInfo);\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * get the dimensions of a monitor\n\t *\n\t * @returns height and weight\n\t * @memberof Utils\n\t */\n\tgetMonitorDimensions: function () {\n\t\treturn new Promise(\n\t\t\tfunction (resolve, reject) {\n\t\t\t\tconsole.debug(\"getMonitorDimensions\");\n\t\t\t\tvar monitorDimensions = {\n\t\t\t\t\theight: null,\n\t\t\t\t\twidth: null\n\n\t\t\t\t};\n\t\t\t\tconsole.debug('getting data');\n\t\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\n\t\t\t\t\tconsole.debug('got monitorInfo', monitorInfo);\n\t\t\t\t\t//top bar is 45..\n\t\t\t\t\tmonitorDimensions.height = monitorInfo.primaryMonitor.availableRect.bottom - monitorInfo.primaryMonitor.availableRect.top - 32;\n\t\t\t\t\tmonitorDimensions.width = monitorInfo.primaryMonitor.availableRect.right;\n\t\t\t\t\tmonitorDimensions.left = monitorInfo.primaryMonitor.availableRect.left;\n\t\t\t\t\tmonitorDimensions.top = monitorInfo.primaryMonitor.availableRect.top;\n\t\t\t\t\tresolve(monitorDimensions);\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t},\n\n\t/**\n\t * Gets an array of monitor descriptors. Essentially rationalizing the results of OpenFin getMonitorInfo.\n\t * into a single array with additional information added.\n\t *\n\t * whichMonitor is set to the secondary monitor number, or \"primary\" if the primary monitor.\n\t * position is set to a zero index, where primary is the zero position, and each non-primary increments thereafter.\n\t *\n\t * Additionally, width and height are calculated and filled in for availableRect and monitorRect.\n\t *\n\t * @param {callback-array} cb Returns a list of monitor descriptors (optional or use promise)\n\t * @returns {Promise} A promise that resolves to a list of monitor descriptors\n\t */\n\tgetAllMonitors: function (cb) {\n\t\treturn new Promise(function (resolve) {\n\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\n\t\t\t\t//console.log(\"getAllMonitors\");\n\t\t\t\tvar allMonitors = [];\n\t\t\t\tvar primaryMonitor = module.exports.clone(monitorInfo.primaryMonitor);\n\t\t\t\tprimaryMonitor.whichMonitor = \"primary\";\n\t\t\t\tprimaryMonitor.position = 0;\n\t\t\t\tallMonitors.push(primaryMonitor);\n\t\t\t\tfor (let i = 0; i < monitorInfo.nonPrimaryMonitors.length; i++) {\n\t\t\t\t\tlet monitor = monitorInfo.nonPrimaryMonitors[i];\n\t\t\t\t\tmonitor.whichMonitor = i;\n\t\t\t\t\tmonitor.position = i + 1;\n\t\t\t\t\tallMonitors.push(module.exports.clone(monitor));\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < allMonitors.length; i++) {\n\t\t\t\t\tlet monitor = allMonitors[i];\n\t\t\t\t\tmodule.exports.rationalizeMonitor(monitor);\n\t\t\t\t}\n\t\t\t\tif (cb) { cb(allMonitors); }\n\t\t\t\tresolve(allMonitors);\n\t\t\t});\n\t\t});\n\t},\n\n\trationalizeMonitor: function (monitor) {\n\t\tmonitor.monitorRect.width = monitor.monitorRect.right - monitor.monitorRect.left;\n\t\tmonitor.monitorRect.height = monitor.monitorRect.bottom - monitor.monitorRect.top;\n\t\tmonitor.availableRect.width = monitor.availableRect.right - monitor.availableRect.left;\n\t\tmonitor.availableRect.height = monitor.availableRect.bottom - monitor.availableRect.top;\n\t},\n\t/**\n\t * Retrieves a monitor descriptor given an absolute X Y on the OpenFin virtual screen\n\t * @param  {number} x The x position\n\t * @param  {number} y The y position\n\t * @param {callback-object}  cb Returns the monitor information from OpenFin.\n\t * \"isPrimary\" is set to true if it's the primary monitor.\n\t * null is returned if the x,y coordinates are beyond the bounds of the virtual screen.\n\t */\n\tgetMonitorFromOpenFinXY: function (x, y, cb) {\n\t\tmodule.exports.getAllMonitors(function (monitors) {\n\t\t\t//\tconsole.log(\"getMonitorFromOpenFinXY\");\n\t\t\tfor (var i = 0; i < monitors.length; i++) {\n\t\t\t\tvar monitor = monitors[i];\n\t\t\t\tvar monitorRect = monitor.monitorRect;\n\t\t\t\t// Are our coordinates inside the monitor? Note that\n\t\t\t\t// left and top are inclusive. right and bottom are exclusive\n\t\t\t\t// In OpenFin, two adjacent monitors will share a right and left pixel value!\n\t\t\t\tif (x >= monitorRect.left && x < monitorRect.right &&\n\t\t\t\t\ty >= monitorRect.top && y < monitorRect.bottom) {\n\t\t\t\t\tcb(monitor);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb(null);\n\t\t});\n\t},\n\n\t/**\n\t * Retrieves a monitor descriptor for a window. If the window straddles two monitors\n\t * then the monitor from the top left is provided and \"straddling\" flag is set to true.\n\t *\n\t * @param  {LauncherClient~windowDescriptor}   windowDescriptor A windowDescriptor\n\t * @param  {Function} cb               Returns a monitor descriptor (optional or use promise)\n\t * @returns {Promise} A promise that resolves to a monitor descriptor\n\t */\n\tgetMonitorFromWindow: function (windowDescriptor, cb) {\n\t\tvar x = windowDescriptor.x || windowDescriptor.defaultLeft;\n\t\tvar y = windowDescriptor.y || windowDescriptor.defaultTop;\n\t\tvar x2 = x + windowDescriptor.defaultWidth;\n\t\tvar y2 = y + windowDescriptor.defaultHeight;\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tmodule.exports.getMonitorFromOpenFinXY(x, y, function (monitor) {\n\t\t\t\tconsole.debug(\"getMonitorFromWindow\");\n\t\t\t\tif (!monitor) {\n\t\t\t\t\tconsole.log(\"getMonitorFromWindow invariant. Can't find monitor for window\");\n\t\t\t\t\tif (cb) {\n\t\t\t\t\t\tcb(null);\n\t\t\t\t\t}\n\t\t\t\t\treject(new Error('Cannot find monitor for window.'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmonitor = module.exports.clone(monitor);\n\t\t\t\tvar monitorRect = monitor.monitorRect;\n\t\t\t\tif (monitorRect.right > x2 || monitorRect.bottom > y2) {\n\t\t\t\t\tmonitor.straddling = true;\n\t\t\t\t}\n\t\t\t\tif (cb) { cb(monitor); }\n\t\t\t\tresolve(monitor);\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Returns a finWindow or null if not found\n\t * @param  {LauncherClient~windowIdentifier}   windowIdentifier A window identifier\n\t * @param  {Function} cb               Optional callback containing finWindow or null if not found (or use Promise)\n\t * @return {Promise}                    Promise that resulves to a finWindow or rejects if not found\n\t */\n\tgetFinWindow: function (windowIdentifier, cb) {\n\t\tconsole.debug(\"getFinWindow\");\n\t\tLogger.system.log('Util.getFinWindow - start');\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\t// Default to current window\n\t\t\tvar myWindow = fin.desktop.Window.getCurrent();\n\n\t\t\t// Get OpenFin options (windowDescriptor) for current window\n\t\t\t// we need this info even if we're going to reference a different window\n\t\t\tLogger.system.log('Util.getFinWindow.getOptions - start');\n\t\t\tmyWindow.getOptions(function (options) {\n\t\t\t\tLogger.system.log('Util.getFinWindow.getOptions - callback');\n\t\t\t\t// If windowName is provided, then find that window\n\t\t\t\tif (windowIdentifier && windowIdentifier.windowName) {\n\t\t\t\t\t// If we didn't get a uuid from the caller, then assume\n\t\t\t\t\t// it's the same window as current window\n\t\t\t\t\tif (!windowIdentifier.uuid) {\n\t\t\t\t\t\twindowIdentifier.uuid = options.uuid;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * Try to wrap the window; if it exists, getInfo will get in\n\t\t\t\t\t *  to the success function. If not, it'll go into the error callback.\n\t\t\t\t\t */\n\t\t\t\t\tlet remoteWindow = fin.desktop.Window.wrap(windowIdentifier.uuid, windowIdentifier.windowName);\n\t\t\t\t\tLogger.system.log('Util.getFinWindow.remoteWindow.getInfo - Start');\n\t\t\t\t\tremoteWindow.getInfo((info) => {\n\t\t\t\t\t\tLogger.system.log('Util.getFinWindow.remoteWindow.getInfo - callback');\n\t\t\t\t\t\tif (cb) { cb(remoteWindow); };\n\n\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 462');\n\t\t\t\t\t\tresolve(remoteWindow);\n\t\t\t\t\t}, function (err) {\n\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 465');\n\t\t\t\t\t\tif (cb) { cb(null); }\n\t\t\t\t\t\treject(\"Window \" + windowIdentifier.windowName + \" not found.\" + `UUID: ${windowIdentifier.uuid}`);\n\t\t\t\t\t\tconsole.debug(\"util.getFinWindow: Window \" + windowIdentifier.windowName + \" not found\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t});\n\t\t\t\t} else if (windowIdentifier && windowIdentifier.componentType) {\n\t\t\t\t\tif (typeof LauncherService !== 'undefined') {\n\t\t\t\t\t\tlet remoteWindow = LauncherService.componentFinder(windowIdentifier);\n\t\t\t\t\t\tif (remoteWindow) {\n\t\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 475');\n\t\t\t\t\t\t\tresolve(remoteWindow);\n\t\t\t\t\t\t\tif (cb) { cb(remoteWindow); }\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 479');\n\t\t\t\t\t\t\treject(\"util.getFinWindow: Component \" + windowIdentifier.componentType + \" not found.\");\n\t\t\t\t\t\t\tif (cb) { cb(null); }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 484');\n\t\t\t\t\t\t//@TODO, get this through a remote call to Launcher service\n\t\t\t\t\t\treject(\"getFinWindow by componentType is currently only operable within LaunchService\");\n\t\t\t\t\t\tif (cb) { cb(null); }\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 490');\n\t\t\t\t\t// return windowDescriptor for current window\n\t\t\t\t\tif (cb) { cb(myWindow); }\n\t\t\t\t\tresolve(myWindow);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Retrieves a windowDescriptor given a windowIdentifier\n\t * @param {LauncherClient~windowIdentifier} [windowIdentifier] The window to locate. If empty then the current window is returned.\n\t * @callback {function} cb Function to retrieve result (optional or use Promise)\n\t * @returns {Promise} A promise that resolves to a LauncherClient~windowDescriptor\n\t */\n\tgetWindowDescriptor: function (windowIdentifier, cb) {\n\t\tconsole.debug(\"getWindowDescriptor\");\n\t\tLogger.system.log('Util.getWindowDescriptor - start');\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tLogger.system.log('Util.getWindowDescriptor.getFinWindow - Start');\n\t\t\tmodule.exports.getFinWindow(windowIdentifier).then(function (finWindow) {\n\t\t\t\tLogger.system.log('Util.getWindowDescriptor.getFinWindow - Callback');\n\t\t\t\tLogger.system.log('Util.getWindowDescriptor.getOptions - Start');\n\t\t\t\tfinWindow.getOptions(function (options) {\n\t\t\t\t\tLogger.system.log('Util.getWindowDescriptor.getOptions - Callback');\n\t\t\t\t\tif (cb) { cb(options); }\n\t\t\t\t\tLogger.system.log('Util.getWindowDescriptor - End');\n\t\t\t\t\tresolve(options);\n\t\t\t\t});\n\t\t\t}).catch(function (errorMessage) {\n\t\t\t\tconsole.warn(errorMessage);\n\t\t\t\tLogger.system.log('Util.getWindowDescriptor - End -- Warn');\n\t\t\t\tif (cb) { cb(null); }\n\t\t\t\treject(errorMessage);\n\t\t\t});\n\t\t});\n\t},\n\n\tfindMonitor: function (monitors, field, value) {\n\t\tfor (var i = 0; i < monitors.length; i++) {\n\t\t\tvar monitor = monitors[i];\n\t\t\tif (monitor[field] === value) { return monitor; }\n\t\t}\n\t\treturn null;\n\t},\n\t/**\n\t * @param {number} commandMonitor\n\t * @param {array} monitors\n\t * @param {number} launchingMonitorPosition\n\t * commandMonitor, monitors, launchingMonitorPosition\n\t */\n\tgetWhichMonitor: function (params, cb) {\n\t\t//First release of this method took 3 params.\n\t\tif (arguments.length > 2) {\n\t\t\tparams = {\n\t\t\t\tcommandMonitor: arguments[0],\n\t\t\t\tmonitors: arguments[1],\n\t\t\t\tlaunchingMonitorPosition: arguments[2]\n\t\t\t};\n\t\t\tcb = null;\n\t\t}\n\t\tvar monitor;\n\t\tvar { commandMonitor, monitors, launchingMonitorPosition } = params;\n\t\tvar isANumber = (commandMonitor && commandMonitor !== \"\") || commandMonitor === 0;\n\t\tif (commandMonitor === \"primary\") {\n\t\t\tmonitor = module.exports.findMonitor(monitors, \"whichMonitor\", \"primary\");\n\t\t} else if (commandMonitor === \"next\") {\n\t\t\tlet position = launchingMonitorPosition + 1;\n\t\t\tif (position >= monitors.length) {\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t\tmonitor = monitors[position];\n\t\t} else if (commandMonitor === \"previous\") {\n\t\t\tlet position = launchingMonitorPosition - 1;\n\t\t\tif (position < 0) {\n\t\t\t\tposition = monitors.length - 1;\n\t\t\t}\n\t\t\tmonitor = monitors[position];\n\t\t} else if (commandMonitor === 'mine') {\n\t\t\tvar waiting = true;\n\t\t\tmodule.exports.getFinWindow(params.windowIdentifier).then(function (finWin) {\n\t\t\t\tfinWin.getBounds((bounds) => {\n\t\t\t\t\tmodule.exports.getMonitorFromOpenFinXY(bounds.left, bounds.top, function (monitor) {\n\t\t\t\t\t\tcb(monitor);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} else if (isANumber) {\n\t\t\tif (commandMonitor >= monitors.length) {\n\t\t\t\tcommandMonitor = monitors.length - 1;\n\t\t\t}\n\t\t\tmonitor = monitors[commandMonitor];\n\t\t} else {\n\t\t\tmonitor = monitors[launchingMonitorPosition];\n\t\t}\n\t\tif (!waiting) {\n\t\t\tif (cb) {\n\t\t\t\tcb(monitor);\n\t\t\t} else {\n\t\t\t\t//maintaining backwards compatibility\n\t\t\t\treturn monitor;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Gets a monitorInfo based on a command. A command is the typical \"monitor\" param\n\t * @param  {string} commandMonitor   Monitor command. See {@link LauncherClient#spawn}\n\t * @param  {object} windowIdentifier The windowIdentifier of the calling function. Necessary to support \"next\",\"previous\" an default.\n\t * @param {function} [cb] Optional callback\n\t * @returns {Promise} A promise that resolves to a monitorInfo\n\t */\n\tgetMonitorFromCommand: function (commandMonitor, windowIdentifier, cb) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tmodule.exports.getMonitor(windowIdentifier, function (monitorInfo) {\n\t\t\t\tmodule.exports.getAllMonitors(function (monitors) {\n\t\t\t\t\tlet params = {\n\t\t\t\t\t\tcommandMonitor: commandMonitor,\n\t\t\t\t\t\tmonitors: monitors,\n\t\t\t\t\t\tlaunchingMonitorPosition: monitorInfo.position\n\t\t\t\t\t};\n\t\t\t\t\tmodule.exports.getWhichMonitor(params, function (finalMonitorInfo) {\n\t\t\t\t\t\tif (cb) { cb(finalMonitorInfo); }\n\t\t\t\t\t\tresolve(finalMonitorInfo);\n\t\t\t\t\t});\n\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * @private\n\t * @param {LauncherClient~windowDescriptor} windowDescriptor\n\t * @param {monitorDimensions} monitorDimensions\n\t * @returns {boolean} Whether window is on the current monitor.\n\t */\n\twindowOnMonitor: function (windowDescriptor, monitorDimensions) {\n\t\t//if right or left edge is within the window's bounds.\n\t\tif ((windowDescriptor.left >= monitorDimensions.left && windowDescriptor.left < monitorDimensions.right) ||\n\t\t\t(windowDescriptor.right <= monitorDimensions.right && windowDescriptor.right > monitorDimensions.left)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t * Convenience function to get the monitor for the current window\n\t * @param {LauncerClient~windowIdentifier} [windowIdentifier] The window to find the monitor for. Current window if empty.\n\t * @param  {Function} cb Returns a monitor descriptor (optional or use Promise)\n\t * @returns {Promise} A promise that resolves to a monitor descriptor\n\t */\n\tgetMonitor: function (windowIdentifier, cb) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tmodule.exports.getWindowDescriptor(windowIdentifier, function (windowDescriptor) {\n\t\t\t\tif (!windowDescriptor) {\n\t\t\t\t\treject(\"util.getMonitor: Can't locate windowDescriptor.\");\n\t\t\t\t} else {\n\t\t\t\t\tmodule.exports.getMonitorFromWindow(windowDescriptor, function (monitor) {\n\t\t\t\t\t\tif (cb) { cb(monitor); }\n\t\t\t\t\t\tresolve(monitor);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\t/**\n\t * Returns a windowIdentifier for the current window\n\t * @param {LauncherClient~windowIdentifier} cb Callback function returns windowIdentifier for this window (optional or use Promise)\n\t * @returns {Promise} A promise that resolves to a windowIdentifier\n\t */\n\tgetMyWindowIdentifier: function (cb) {\n\t\tvar finWindow = fin.desktop.Window.getCurrent();\n\t\tLogger.system.log('Util.getMyWindowIdentifier - start');\n\t\treturn new Promise(function (resolve) {\n\t\t\tfinWindow.getOptions((windowDescriptor) => {\n\t\t\t\tvar componentType = null;\n\n\t\t\t\t// Figure out the component type from what was originally stored when we launched the window\n\t\t\t\t// options.customData is where our stuff is found\n\t\t\t\tvar customData = windowDescriptor.customData;\n\t\t\t\tif (customData && customData.component) {\n\t\t\t\t\tcomponentType = customData.component.type;\n\t\t\t\t}\n\t\t\t\tvar windowIdentifier = {\n\t\t\t\t\twindowName: finWindow.name,\n\t\t\t\t\tuuid: finWindow.uuid,\n\t\t\t\t\tcomponentType: componentType\n\t\t\t\t};\n\t\t\t\tLogger.system.log('Util.getMyWindowIdentifier - End');\n\n\t\t\t\tif (cb) { cb(windowIdentifier); }\n\t\t\t\tresolve(windowIdentifier);\n\t\t\t});\n\t\t});\n\t},\n\t/**\n\t *\t@returns {string} Transforms an array of strings into a camelcased string.\n\t * @memberof Utils\n\t */\n\tcamelCase: function () {\n\t\tvar str = '';\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tstr += ' ' + arguments[i];\n\t\t}\n\t\treturn str\n\t\t\t.replace(/\\s(.)/g, function ($1) { return $1.toUpperCase(); })\n\t\t\t.replace(/\\s/g, '')\n\t\t\t.replace(/^(.)/, function ($1) { return $1.toLowerCase(); });\n\t},\n\n\t/**\n\t * Convenience method for cloning an object.\n\t * @param  {any} from The thing you want to copy\n\t * @param {any} to Where you want your copy to end up.\n\t * @return {any} to Where you want your copy to end up.\n\t */\n\tclone: function (from, to) {\n\t\tif (from === null || typeof from !== \"object\") { return from; }\n\t\t// if (from.constructor != Object && from.constructor != Array) return from;\n\t\tif (from.constructor == Date || from.constructor == RegExp || from.constructor == Function ||\n\t\t\tfrom.constructor == String || from.constructor == Number || from.constructor == Boolean) { return new from.constructor(from); }\n\n\t\tto = to || new from.constructor();\n\n\t\tfor (var n in from) {\n\t\t\tto[n] = typeof to[n] === \"undefined\" ? module.exports.clone(from[n], null) : to[n];\n\t\t}\n\n\t\treturn to;\n\t},\n\n\tgetUniqueName: function (baseName) {\n\t\tif (!baseName) {\n\t\t\tbaseName = \"RouterClient\";\n\t\t}\n\t\tvar uuid = baseName + \"-\" + Math.floor(Math.random() * 100) + \"-\" + Math.floor(Math.random() * 10000);\n\t\treturn uuid;\n\t},\n\n\tinjectJS(path, cb) {//Inject a script tag with the path given. Once the script is loaded, it executes the callback.\n\n\t\tvar script = document.createElement('script');\n\t\tscript.onload = cb;\n\t\tscript.type = 'text/javascript';\n\t\tscript.async = true;\n\t\tscript.src = path;\n\t\tvar head = document.getElementsByTagName('head')[0];\n\t\tvar firstScript = head.getElementsByTagName('script')[0];\n\t\thead.insertBefore(script, firstScript);\n\n\t},\n};\n\n\n\n// WEBPACK FOOTER //\n// src/common/util.js","function Agent() {\n  this._defaults = [];\n}\n\n[\"use\", \"on\", \"once\", \"set\", \"query\", \"type\", \"accept\", \"auth\", \"withCredentials\", \"sortQuery\", \"retry\", \"ok\", \"redirects\",\n \"timeout\", \"buffer\", \"serialize\", \"parse\", \"ca\", \"key\", \"pfx\", \"cert\"].forEach(function(fn) {\n  /** Default setting for all requests from this agent */\n  Agent.prototype[fn] = function(/*varargs*/) {\n    this._defaults.push({fn:fn, arguments:arguments});\n    return this;\n  }\n});\n\nAgent.prototype._setDefaults = function(req) {\n    this._defaults.forEach(function(def) {\n      req[def.fn].apply(req, def.arguments);\n    });\n};\n\nmodule.exports = Agent;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/superagent/lib/agent-base.js\n// module id = 230\n// module chunks = 0 2 4","'use strict';\n\n/**\n * Module of mixed-in functions shared between node and client code\n */\nvar isObject = require('./is-object');\n\n/**\n * Expose `RequestBase`.\n */\n\nmodule.exports = RequestBase;\n\n/**\n * Initialize a new `RequestBase`.\n *\n * @api public\n */\n\nfunction RequestBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in RequestBase.prototype) {\n    obj[key] = RequestBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.clearTimeout = function _clearTimeout(){\n  clearTimeout(this._timer);\n  clearTimeout(this._responseTimeoutTimer);\n  delete this._timer;\n  delete this._responseTimeoutTimer;\n  return this;\n};\n\n/**\n * Override default response body parser\n *\n * This function will be called to convert incoming data into request.body\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set format of binary response body.\n * In browser valid formats are 'blob' and 'arraybuffer',\n * which return Blob and ArrayBuffer, respectively.\n *\n * In Node all values result in Buffer.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Override default request body serializer\n *\n * This function will be called to convert data set via .send or .attach into payload to send\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.serialize = function serialize(fn){\n  this._serializer = fn;\n  return this;\n};\n\n/**\n * Set timeouts.\n *\n * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.\n * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.\n *\n * Value of 0 or false means no timeout.\n *\n * @param {Number|Object} ms or {response, deadline}\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.timeout = function timeout(options){\n  if (!options || 'object' !== typeof options) {\n    this._timeout = options;\n    this._responseTimeout = 0;\n    return this;\n  }\n\n  for(var option in options) {\n    switch(option) {\n      case 'deadline':\n        this._timeout = options.deadline;\n        break;\n      case 'response':\n        this._responseTimeout = options.response;\n        break;\n      default:\n        console.warn(\"Unknown timeout option\", option);\n    }\n  }\n  return this;\n};\n\n/**\n * Set number of retry attempts on error.\n *\n * Failed requests will be retried 'count' times if timeout or err.code >= 500.\n *\n * @param {Number} count\n * @param {Function} [fn]\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.retry = function retry(count, fn){\n  // Default to 1 if no count passed or true\n  if (arguments.length === 0 || count === true) count = 1;\n  if (count <= 0) count = 0;\n  this._maxRetries = count;\n  this._retries = 0;\n  this._retryCallback = fn;\n  return this;\n};\n\nvar ERROR_CODES = [\n  'ECONNRESET',\n  'ETIMEDOUT',\n  'EADDRINFO',\n  'ESOCKETTIMEDOUT'\n];\n\n/**\n * Determine if a request should be retried.\n * (Borrowed from segmentio/superagent-retry)\n *\n * @param {Error} err\n * @param {Response} [res]\n * @returns {Boolean}\n */\nRequestBase.prototype._shouldRetry = function(err, res) {\n  if (!this._maxRetries || this._retries++ >= this._maxRetries) {\n    return false;\n  }\n  if (this._retryCallback) {\n    try {\n      var override = this._retryCallback(err, res);\n      if (override === true) return true;\n      if (override === false) return false;\n      // undefined falls back to defaults\n    } catch(e) {\n      console.error(e);\n    }\n  }\n  if (res && res.status && res.status >= 500 && res.status != 501) return true;\n  if (err) {\n    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;\n    // Superagent timeout\n    if (err.timeout && err.code == 'ECONNABORTED') return true;\n    if (err.crossDomain) return true;\n  }\n  return false;\n};\n\n/**\n * Retry request\n *\n * @return {Request} for chaining\n * @api private\n */\n\nRequestBase.prototype._retry = function() {\n\n  this.clearTimeout();\n\n  // node\n  if (this.req) {\n    this.req = null;\n    this.req = this.request();\n  }\n\n  this._aborted = false;\n  this.timedout = false;\n\n  return this._end();\n};\n\n/**\n * Promise support\n *\n * @param {Function} resolve\n * @param {Function} [reject]\n * @return {Request}\n */\n\nRequestBase.prototype.then = function then(resolve, reject) {\n  if (!this._fullfilledPromise) {\n    var self = this;\n    if (this._endCalled) {\n      console.warn(\"Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises\");\n    }\n    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {\n      self.end(function(err, res) {\n        if (err) innerReject(err);\n        else innerResolve(res);\n      });\n    });\n  }\n  return this._fullfilledPromise.then(resolve, reject);\n};\n\nRequestBase.prototype.catch = function(cb) {\n  return this.then(undefined, cb);\n};\n\n/**\n * Allow for extension\n */\n\nRequestBase.prototype.use = function use(fn) {\n  fn(this);\n  return this;\n};\n\nRequestBase.prototype.ok = function(cb) {\n  if ('function' !== typeof cb) throw Error(\"Callback required\");\n  this._okCallback = cb;\n  return this;\n};\n\nRequestBase.prototype._isResponseOK = function(res) {\n  if (!res) {\n    return false;\n  }\n\n  if (this._okCallback) {\n    return this._okCallback(res);\n  }\n\n  return res.status >= 200 && res.status < 300;\n};\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nRequestBase.prototype.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nRequestBase.prototype.getHeader = RequestBase.prototype.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nRequestBase.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val`, or multiple fields with one object\n * for \"multipart/form-data\" request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n *\n * request.post('/upload')\n *   .field({ foo: 'bar', baz: 'qux' })\n *   .end(callback);\n * ```\n *\n * @param {String|Object} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nRequestBase.prototype.field = function(name, val) {\n  // name should be either a string or an object.\n  if (null === name || undefined === name) {\n    throw new Error('.field(name, val) name can not be empty');\n  }\n\n  if (this._data) {\n    console.error(\".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObject(name)) {\n    for (var key in name) {\n      this.field(key, name[key]);\n    }\n    return this;\n  }\n\n  if (Array.isArray(val)) {\n    for (var i in val) {\n      this.field(name, val[i]);\n    }\n    return this;\n  }\n\n  // val should be defined now\n  if (null === val || undefined === val) {\n    throw new Error('.field(name, val) val can not be empty');\n  }\n  if ('boolean' === typeof val) {\n    val = '' + val;\n  }\n  this._getFormData().append(name, val);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\nRequestBase.prototype.abort = function(){\n  if (this._aborted) {\n    return this;\n  }\n  this._aborted = true;\n  this.xhr && this.xhr.abort(); // browser\n  this.req && this.req.abort(); // node\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\nRequestBase.prototype._auth = function(user, pass, options, base64Encoder) {\n  switch (options.type) {\n    case 'basic':\n      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));\n      break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n      break;\n\n    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })\n      this.set('Authorization', 'Bearer ' + user);\n      break;\n  }\n  return this;\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequestBase.prototype.withCredentials = function(on) {\n  // This is browser-only functionality. Node side is no-op.\n  if (on == undefined) on = true;\n  this._withCredentials = on;\n  return this;\n};\n\n/**\n * Set the max redirects to `n`. Does noting in browser XHR implementation.\n *\n * @param {Number} n\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.redirects = function(n){\n  this._maxRedirects = n;\n  return this;\n};\n\n/**\n * Maximum size of buffered response body, in bytes. Counts uncompressed size.\n * Default 200MB.\n *\n * @param {Number} n\n * @return {Request} for chaining\n */\nRequestBase.prototype.maxResponseSize = function(n){\n  if ('number' !== typeof n) {\n    throw TypeError(\"Invalid argument\");\n  }\n  this._maxResponseSize = n;\n  return this;\n};\n\n/**\n * Convert to a plain javascript object (not JSON string) of scalar properties.\n * Note as this method is designed to return a useful non-this value,\n * it cannot be chained.\n *\n * @return {Object} describing method, url, and data of this request\n * @api public\n */\n\nRequestBase.prototype.toJSON = function() {\n  return {\n    method: this.method,\n    url: this.url,\n    data: this._data,\n    headers: this._header,\n  };\n};\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n *      request.post('/user')\n *        .send('name=tobi')\n *        .send('species=ferret')\n *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.send = function(data){\n  var isObj = isObject(data);\n  var type = this._header['content-type'];\n\n  if (this._formData) {\n    console.error(\".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObj && !this._data) {\n    if (Array.isArray(data)) {\n      this._data = [];\n    } else if (!this._isHost(data)) {\n      this._data = {};\n    }\n  } else if (data && this._data && this._isHost(this._data)) {\n    throw Error(\"Can't merge these send calls\");\n  }\n\n  // merge\n  if (isObj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    // default to x-www-form-urlencoded\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!isObj || this._isHost(data)) {\n    return this;\n  }\n\n  // default to json\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Sort `querystring` by the sort function\n *\n *\n * Examples:\n *\n *       // default order\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery()\n *         .end(callback)\n *\n *       // customized sort function\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery(function(a, b){\n *           return a.length - b.length;\n *         })\n *         .end(callback)\n *\n *\n * @param {Function} sort\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.sortQuery = function(sort) {\n  // _sort default to true but otherwise can be a function or boolean\n  this._sort = typeof sort === 'undefined' ? true : sort;\n  return this;\n};\n\n/**\n * Compose querystring to append to req.url\n *\n * @api private\n */\nRequestBase.prototype._finalizeQueryString = function(){\n  var query = this._query.join('&');\n  if (query) {\n    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;\n  }\n  this._query.length = 0; // Makes the call idempotent\n\n  if (this._sort) {\n    var index = this.url.indexOf('?');\n    if (index >= 0) {\n      var queryArr = this.url.substring(index + 1).split('&');\n      if ('function' === typeof this._sort) {\n        queryArr.sort(this._sort);\n      } else {\n        queryArr.sort();\n      }\n      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');\n    }\n  }\n};\n\n// For backwards compat only\nRequestBase.prototype._appendQueryString = function() {console.trace(\"Unsupported\");}\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequestBase.prototype._timeoutError = function(reason, timeout, errno){\n  if (this._aborted) {\n    return;\n  }\n  var err = new Error(reason + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  err.code = 'ECONNABORTED';\n  err.errno = errno;\n  this.timedout = true;\n  this.abort();\n  this.callback(err);\n};\n\nRequestBase.prototype._setTimeouts = function() {\n  var self = this;\n\n  // deadline\n  if (this._timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self._timeoutError('Timeout of ', self._timeout, 'ETIME');\n    }, this._timeout);\n  }\n  // response timeout\n  if (this._responseTimeout && !this._responseTimeoutTimer) {\n    this._responseTimeoutTimer = setTimeout(function(){\n      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');\n    }, this._responseTimeout);\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/superagent/lib/request-base.js\n// module id = 231\n// module chunks = 0 2 4","'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar utils = require('./utils');\n\n/**\n * Expose `ResponseBase`.\n */\n\nmodule.exports = ResponseBase;\n\n/**\n * Initialize a new `ResponseBase`.\n *\n * @api public\n */\n\nfunction ResponseBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in ResponseBase.prototype) {\n    obj[key] = ResponseBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponseBase.prototype.get = function(field) {\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponseBase.prototype._setHeaderProperties = function(header){\n    // TODO: moar!\n    // TODO: make this a util\n\n    // content-type\n    var ct = header['content-type'] || '';\n    this.type = utils.type(ct);\n\n    // params\n    var params = utils.params(ct);\n    for (var key in params) this[key] = params[key];\n\n    this.links = {};\n\n    // links\n    try {\n        if (header.link) {\n            this.links = utils.parseLinks(header.link);\n        }\n    } catch (err) {\n        // ignore\n    }\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponseBase.prototype._setStatusProperties = function(status){\n    var type = status / 100 | 0;\n\n    // status / class\n    this.status = this.statusCode = status;\n    this.statusType = type;\n\n    // basics\n    this.info = 1 == type;\n    this.ok = 2 == type;\n    this.redirect = 3 == type;\n    this.clientError = 4 == type;\n    this.serverError = 5 == type;\n    this.error = (4 == type || 5 == type)\n        ? this.toError()\n        : false;\n\n    // sugar\n    this.accepted = 202 == status;\n    this.noContent = 204 == status;\n    this.badRequest = 400 == status;\n    this.unauthorized = 401 == status;\n    this.notAcceptable = 406 == status;\n    this.forbidden = 403 == status;\n    this.notFound = 404 == status;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/superagent/lib/response-base.js\n// module id = 232\n// module chunks = 0 2 4","'use strict';\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.type = function(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.params = function(str){\n  return str.split(/ *; */).reduce(function(obj, str){\n    var parts = str.split(/ *= */);\n    var key = parts.shift();\n    var val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Parse Link header fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.parseLinks = function(str){\n  return str.split(/ *, */).reduce(function(obj, str){\n    var parts = str.split(/ *; */);\n    var url = parts[0].slice(1, -1);\n    var rel = parts[1].split(/ *= */)[1].slice(1, -1);\n    obj[rel] = url;\n    return obj;\n  }, {});\n};\n\n/**\n * Strip content related fields from `header`.\n *\n * @param {Object} header\n * @return {Object} header\n * @api private\n */\n\nexports.cleanHeader = function(header, shouldStripCookie){\n  delete header['content-type'];\n  delete header['content-length'];\n  delete header['transfer-encoding'];\n  delete header['host'];\n  if (shouldStripCookie) {\n    delete header['cookie'];\n  }\n  return header;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/superagent/lib/utils.js\n// module id = 233\n// module chunks = 0 2 4","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\nvar SystemSettings = require(\"./systemSettings\");\n\n/**\n * @introduction\n * <h2>Finsemble Vaidate Functions</h2>\n * \n */\n\n/**\n * Constructor for Finsemble argment validator.\n *\n * Validatation logic is ONLY RAN when SystemSettings diagnotics level is set to debug (i.e. 4 or above)\n * A failed validation will generate a warning message, but nothing more; however application logic can check the validation results.\n *\n * @param {string} console Finsemble console object used to display messages and check diagnotic level \n * @constructor\n */\t\nvar Validate = function () {\n\n\tfunction warningMsg(paramDescript, thisArg, thisArgType) {\n\n\t\tfunction getErrorObject() {\n\t\t\ttry { throw Error(''); } catch (err) { return err; }\n\t\t}\n\n\t\tvar err = getErrorObject();\n\n\t\tvar caller_line1 = err.stack.split(\"\\n\")[5];\n\t\tvar index1 = caller_line1.indexOf(\"at \");\n\t\tvar msgPart1 = caller_line1.slice(index1 + 2, caller_line1.length);\n\n\t\tvar caller_line2 = err.stack.split(\"\\n\")[6];\n\t\tvar index2 = caller_line2.indexOf(\"at \");\n\t\tvar msgPart2 = caller_line2.slice(index2 + 2, caller_line2.length);\n\n\t\tconsole.warn(\"parameter validation failed: parameter \" + paramDescript + \" is of type '\" + typeof (thisArg) + \"' but should be of type '\" + thisArgType + \"' in\" + msgPart1 + \" called by\" + msgPart2);\n\t}\n\t\n\t/**\n\t * Confirm parameters are valid. A variable number of parameter pairs are supported. \n\t * @param {any} param1 is arg to validate\n\t * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \n\t * @param {any=} param2 is next arg to validate\n\t * @param {string=} paramType2 os required type for next arg \n\t * @return {boolean} returns turn if parameter list is valid; otherwise, false.\n\t *\n\t * @example\n\t *\n\t * var validate = new Validate(console); \n\t * validate.args(name, \"string\", age, \"number\")\n\t *\n\t * validate.args(topic, \"string\", initialState, \"object=\"); // with optional paramter (represented by \"=\")\n\t *\n\t * validate.args(topic, \"string\", initialState, \"any\"); // with \"any\" type\n\t *\n\t * validate.args(subscribeIDStruct, \"object\") && validate.args(subscribeIDStruct.subscribeID, \"string\"); // only do second varidate if first test successful\n\t *\n\t * validate.args(subscribeIDStruct, \"object\", subscribeIDStruct.subscribeID, \"string\"); // only check second parm if first validated successful\n\t *\n\t * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\"); // depending on logic, can break into seperate validations\n\t * params = params || {}; \n\t * validate.args(params.subscribeCallback, \"function=\", params.publishCallback, \"function=\", params.unsubscribeCallback, \"function=\");\n\t */\n\tthis.args = function (param1, paramType1, param2, paramType2 /*.....optional more paramter pairs....*/) {\n\t\tvar returnCode = true;\n\t\tif (SystemSettings.validationEnabled()) {\n\t\t\tvar parmCount = arguments.length;\n\t\t\tif ((parmCount + 1) % 2 !== 0) { // parameters must come in pairs (i.e. even number)\n\t\t\t\tfor (var i = 0; i < parmCount; i = i + 2) {\n\t\t\t\t\tvar optionalArg = false;\n\t\t\t\t\tvar thisArg = arguments[i];\n\t\t\t\t\tvar thisArgType = arguments[i + 1];\n\t\t\t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\n\t\t\t\t\t\tthisArgType = thisArgType.slice(0, -1);\n\t\t\t\t\t\toptionalArg = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\n\t\t\t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\n\t\t\t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\n\t\t\t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\n\t\t\t\t\t\t\t\twarningMsg(parameterPosition, thisArg, thisArgType);\n\t\t\t\t\t\t\t\treturnCode = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"validate.args requires even number of parameters: \" + JSON.stringify(arguments));\n\t\t\t}\n\t\t}\n\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \n\t};\n\n\t/**\n\t * Confirm parameters are valid. args2() has the same functionality as args() except a third \"parameter description\" is passed in for each argument varified\n\t * Typically this for passing in a properties name for better diagnostic messages when varifying object properties.\n\t * A variable number of parameter \"triples\"\" are supported.\n\t *\n\t * @param {string} paramName1 is descriptive name of param1 (for diagnostic message)\n\t * @param {any} param1 is arg to validate\n\t * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\").\n\t * @param {string} paramName2 is descriptive name of param1 (for diagnostic message)\n\t * @param {any} param2 is arg to validate\n\t * @param {string} paramType2 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \n\t * @return {boolean} returns turn if parameter list is valid; otherwise, false.\n\t *\n\t * @example\n\t *\n\t * var validate = new Utils.Validate(console); \n\t * validate.args2(\"record.name\", record.name, \"string\", \"record.age\", age, \"number\")\n\t *\n\t * // common case using args() and args2() together\n\t * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\") &&\n\t *   validate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\n\t *   validate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\n\t */\n\tthis.args2 = function (paramName1, param1, paramType1, paramName2, param2, paramType2 /*.....optional, more paramter sets of three....*/) {\n\n\t\tvar returnCode = true;\n\t\tif (SystemSettings.validationEnabled()) {\n\t\t\tvar parmCount = arguments.length;\n\t\t\tif ((parmCount + 1) % 3 !== 0) { // parameters must come in sets of three \n\t\t\t\tfor (var i = 0; i < parmCount; i = i + 3) {\n\t\t\t\t\tvar optionalArg = false;\n\t\t\t\t\tvar thisArgName = arguments[i];\n\t\t\t\t\tvar thisArg = arguments[i + 1];\n\t\t\t\t\tvar thisArgType = arguments[i + 2];\n\t\t\t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\n\t\t\t\t\t\tthisArgType = thisArgType.slice(0, -1);\n\t\t\t\t\t\toptionalArg = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\n\t\t\t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\n\t\t\t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\n\t\t\t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\n\t\t\t\t\t\t\t\twarningMsg(thisArgName, thisArg, thisArgType);\n\t\t\t\t\t\t\t\treturnCode = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"validate.args requires even number of parameters: \" + JSON.stringify(arguments));\n\t\t\t}\n\t\t}\n\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \n\t};\n};\n\nmodule.exports = new Validate();\n\n\n// WEBPACK FOOTER //\n// src/common/validate.js","//Abstract\n//Takes the name of the storage\nvar BaseStorage = function (args) {\n\tif (args) {\n\t\ttry {//webpack was crying here. It wouldnt let it build without this. Window does not exist server side.\n\t\t\tif (window.finsemble.storageModels) {\n\t\t\t\twindow.finsemble.storageModels[args[0]] = this;\n\t\t\t}\n\t\t} catch (e) {\n\n\n\t\t}\n\n\t}\n\tthis.setBaseName = function (baseName) {\n\t\tthis.baseName = baseName;\n\t};\n\n\tthis.setUser = function (user) {\n\t\tthis.userName = user;\n\t};\n\n\tthis.save = function (params) {\n\n\t};\n\n\tthis.get = function (params) {\n\n\t};\n\n\tthis.keys = function (params) {\n\n\t};\n\n\tthis.delete = function (params) {\n\n\t};\n\n\tthis.clearCache = function (params) {\n\n\t};\n\n\tthis.empty = function () {\n\n\t};\n\tthis.getMultiple = function (query) {\n\n\t};\n\n\t// return full underlying key (based baseName + userName + topic + key)\n\tthis.getCombinedKey = function (self, params) {\n\t\treturn self.baseName + \":\" + self.userName + \":\" + params.topic + \":\" + params.key;\n\t};\n\n\t// return prefix used to filter keys\n\tthis.getKeyPreface = function (self, params) {\n\t\tvar preface = self.baseName + \":\" + self.userName + \":\" + params.topic + \":\";\n\t\tif (\"keyPrefix\" in params) {\n\t\t\tpreface = preface + params.keyPrefix;\n\t\t}\n\t\treturn preface;\n\t};\n\n};\n\nmodule.exports = BaseStorage;\n\n\n\n// WEBPACK FOOTER //\n// src/services/storage/models/base.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n/**\n * @introduction\n * <h2>Router Client Instance</h2>\n * Exports a single shared instance of the router client.  See {@link RouterClientConstructor} for the complete API definition with examples.\n *\n * Example:\n *\n *\t// get a shared instance of RouterClient (shared within the containing component or service)\n *\tvar RouterClient = require('./routerClientInstance');\n *\n * @namespace routerClientInstance\n * @shouldBePublished false\n */\n\n\"use strict\";\n\nvar RouterClientConstructor = require(\"./routerClientConstructor\");\n\nmodule.exports = new RouterClientConstructor({ clientName: \"RouterClient\" });\n\n\n// WEBPACK FOOTER //\n// src/clients/routerClientInstance.js","var BaseStorage = require(\"./base\");\nvar Request = require(\"superagent\");\nvar Logger = require(\"../../../clients/logger\");\n\nvar Redis = function () {\n\n\tBaseStorage.call(this, arguments);\n\tthis.save = function (params, cb) {\n\t\tLogger.system.debug(\"redis-params\", params);\n\t\tRequest\n\t\t\t.post(\"/redis\")\n\t\t\t.set(\"Content-Type\", \"application/x-www-form-urlencoded\")\n\t\t\t.send({\n\t\t\t\tkey: this.getCombinedKey(this, params),\n\t\t\t\tvalue: JSON.stringify(params.value)\n\t\t\t})\n\t\t\t.end(function (err, res) {\n\t\t\t\treturn cb(err, res.body);\n\t\t\t});\n\t};\n\n\tthis.get = function (params, cb) {\n\t\tvar self = this;\n\t\tRequest\n\t\t\t.get(\"/redis\")\n\t\t\t.query({\n\t\t\t\tkey: this.getCombinedKey(this, params)\n\t\t\t})\n\t\t\t.end(function (err, res) {\n\n\t\t\t\tvar returnValue = res.text ? res.text : null;\n\t\t\t\treturn cb(err, JSON.parse(returnValue));\n\t\t\t});\n\n\t};\n\n\tthis.keys = function (params, cb) {\n\t\tLogger.system.debug(\"call to keys\", params);\n\t\tvar self = this;\n\t\tRequest\n\t\t\t.get(\"/redis\")\n\t\t\t.query({\n\t\t\t\tkeys: true\n\t\t\t})\n\t\t\t.end(function (err, res) {\n\t\t\t\tLogger.system.debug(\"keys response:\" + JSON.stringify(res.text));\n\t\t\t\tvar keys = [];\n\t\t\t\tvar keyPreface = self.getKeyPreface(self, params);\n\t\t\t\tvar keysRegExp = new RegExp(keyPreface + \".*\"); // regex to find all keys for this topic\n\t\t\t\tvar allKeys = JSON.parse(res.text);\n\t\t\t\tfor (var i = 0, len = allKeys.length; i < len; ++i) {\n\t\t\t\t\tvar oneKey = allKeys[i];\n\t\t\t\t\tLogger.system.debug(\"keyPrefix=\" + keyPreface);\n\t\t\t\t\tif (keysRegExp.test(oneKey)) { // if key is for this topic then save it\n\t\t\t\t\t\tkeys.push(oneKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tLogger.system.debug(\"Storage.keys for keyPreface=\" + keyPreface + \" with keys=\" + keys);\n\t\t\t\treturn cb(err, keys);\n\t\t\t});\n\t};\n\n\tthis.delete = function (params, cb) {\n\t\tLogger.system.debug(\"call to delete\", params);\n\t\tRequest\n\t\t\t.delete(\"/redis\")\n\t\t\t.query({\n\t\t\t\tkey: this.getCombinedKey(this, params)\n\t\t\t})\n\t\t\t.end(function (err, res) {\n\t\t\t\treturn cb(err, res.texts);\n\t\t\t});\n\n\t};\n\tthis.clearCache = function (params, cb) {\n\t\tLogger.system.debug(\"call to delete\", params);\n\t\tRequest\n\t\t\t.delete(\"/redis/user\")\n\t\t\t.query({\n\t\t\t\tkey: this.baseName + \":\" + this.userName\n\t\t\t})\n\t\t\t.end(function (err, res) {\n\t\t\t\treturn cb(err, res.texts);\n\t\t\t});\n\n\t};\n\n\tthis.empty = function () {\n\n\t\treturn { status: \"success\" };\n\t};\n\n\tthis.getMultiple = function (query) {\n\n\t};\n};\n\n\nRedis.prototype = new BaseStorage();\nnew Redis(\"redis\");\nmodule.exports = Redis;//Allows us to get access to the unintialized object\n\n\n\n// WEBPACK FOOTER //\n// src/services/storage/models/redis.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n/**\n * @introduction\n * <h2>Finsemble system wide settings for use by all components and services</h2>\n *\n */\n\n/**\n * Constructor for Finsemble SystemSettings\n * @private\n * @constructor\n */\nvar SystemSettings = function () {\n\tvar currentDiagLevel = 3;\n\n\t/**\n\t * Returns diagnostic level\n\t *\n\t *@returns current diagnostic level\n\t */\n\tthis.diagLevel = function () {\n\t\treturn currentDiagLevel;\n\t};\n\n\t/**\n\t * Returns diagnostic level\n\t *\n\t *@returns current diagnostic level\n\t */\n\tthis.setDiagLevel = function (level) {\n\t\tcurrentDiagLevel = level;\n\t};\n\n\t/**\n\t * Returns true if parameter validation is enabled\n\t *\n\t *@returns true if enable\n\t */\n\tthis.validationEnabled = function () {\n\t\treturn (currentDiagLevel >= 4);\n\t};\n};\n\nmodule.exports = new SystemSettings();\n\n\n// WEBPACK FOOTER //\n// src/common/systemSettings.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n\"use strict\";\nvar RouterTransport = require(\"../common/routerTransport\");\nvar Utils = require(\"../common/util\");\nvar ConfigUtil = require(\"../common/configUtil\");\nvar Validate = require(\"../common/validate\"); // Finsemble args validator\nvar queue = []; // should never be used, but message sent before router ready will be queue\n\nvar Logger = require(\"./logger\");\nLogger.system.log(\"Starting RouterClient\");\n\n\n/**\n * @introduction\n *\n * <h2>Event Router Client</h2>\n *\n * This module contains the RouterClient for sending and receiving events between Finsemble components and services.  See <a href=tutorial-usingTheEventRouter.html>Event Router Tutorial</a> for an overview of the router's functionality.\n *\n * *Event router callbacks for incoming messages are always in the form `callback(error, event)`.  If `error` is null, then the incoming data is always in `event.data`. If error is set, it contains a diagnotic object and message.  On error, the `event` parameter is not undefined.*\n *\n *\n * @constructor\n * @hideConstructor true\n * @publishedName RouterClient\n * @param {string} thisClientName router client name for human readable messages\n * @param {string=} transportName router transport name, currently either \"SharedWorker\" or \"OpenFinBus\" (usually this is autoconfigured internally but can be selected for testing or special configurations)\n */\nvar RouterClientConstructor = function (params) {\n\tValidate.args(params, \"object\") && Validate.args2(\"params.clientName\", params.clientName, \"string\", \"params.transportName\", params.transportName, \"string=\");\n\n\t///////////////////////////\n\t// Private Data\n\t///////////////////////////\n\tvar thisClientName = params.clientName;\n\tvar transportName = params.transportName;\n\tvar handshakeHandler;\n\tvar timeCalibrationHandler;\n\tvar mapListeners = {};\n\tvar mapResponders = {};\n\tvar mapPubSubResponders = {};\n\tvar mapPubSubResponderState = {};\n\tvar mapPubSubResponderRegEx = {};\n\tvar pubsubListOfSubscribers = {};\n\tvar mapSubscribersID = {};\n\tvar mapSubscribersTopic = {};\n\tvar mapQueryResponses = {};\n\tvar mapQueryResponseTimeOut = {};\n\tvar clientIDCounter = 1000;\n\tvar clientName;\n\tvar transport = false;\n\tvar isRouterReady = false;\n\tvar isParentWaiting = false;\n\tvar parentReadyCallbackQueue = []; // must be queue because may be multiple waiters\n\tvar self = this;\n\n\t/////////////////////////////////////////////////////////////////////\n\t// Private Message Contructors for Communicating with RouterService\n\t/////////////////////////////////////////////////////////////////////\n\n\tfunction InitialHandshakeMessage() {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"initialHandshake\",\n\t\t};\n\t}\n\tfunction TimeCalibrationHandshakeMessage(clientBaseTime, serviceBaseTime) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"timeCalibration\",\n\t\t};\n\t\tthis.clientBaseTime = clientBaseTime;\n\t\tthis.serviceBaseTime = serviceBaseTime;\n\t}\n\tfunction AddListenerMessage(channel) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"addListener\",\n\t\t\t\"channel\": channel\n\t\t};\n\t}\n\tfunction TransmitMessage(toChannel, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"transmit\",\n\t\t\t\"channel\": toChannel\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction RemoveListenerMessage(channel) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"removeListener\",\n\t\t\t\"channel\": channel\n\t\t};\n\t}\n\tfunction addResponderMessage(channel) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"addResponder\",\n\t\t\t\"channel\": channel\n\t\t};\n\t}\n\tfunction QueryMessage(queryID, channel, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"query\",\n\t\t\t\"queryID\": queryID,\n\t\t\t\"channel\": channel\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction QueryResponseMessage(queryID, error, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"queryResponse\",\n\t\t\t\"queryID\": queryID,\n\t\t\t\"error\": error\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction RemoveResponderMessage(channel) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"removeResponder\",\n\t\t\t\"channel\": channel\n\t\t};\n\t}\n\tfunction SubscribeMessage(subscribeID, topic) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"subscribe\",\n\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\"topic\": topic\n\t\t};\n\t}\n\tfunction UnsubscribeMessage(subscribeID, topic) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"unsubscribe\",\n\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\"topic\": topic\n\t\t};\n\t}\n\tfunction PublishMessage(topic, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"publish\",\n\t\t\t\"topic\": topic\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction NotifyMessage(subscribeID, topic, error, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"notify\",\n\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\"topic\": topic,\n\t\t\t\"error\": error\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction AddPubSubResponderMessage(topic) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"addPubSubResponder\",\n\t\t\t\"topic\": topic\n\t\t};\n\t}\n\tfunction RemovePubSubResponderMessage(topic) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"removePubSubResponder\",\n\t\t\t\"topic\": topic\n\t\t};\n\t}\n\tfunction JoinGroupMessage(group) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"joinGroup\",\n\t\t\t\"group\": group\n\t\t};\n\t}\n\tfunction LeaveGroupMessage(group) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"leaveGroup\",\n\t\t\t\"group\": group\n\t\t};\n\t}\n\tfunction GroupTransmitMessage(group, toChannel, message, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"groupTransmit\",\n\t\t\t\"group\": group,\n\t\t\t\"channel\": toChannel\n\t\t};\n\t\tthis.data = data;\n\t}\n\n\t//////////////////////\n\t// Private Functions\n\t//////////////////////\n\n\t// router client is being terminated so cleanup\n\tfunction destructor(event) {\n\t\tvar finWindow = fin.desktop.Window.getCurrent();\n\t\tLogger.system.info(\"RouterClient: shutting down on event: \" + JSON.stringify(event));\n\t\tself.disconnectAll(); // this will let the router know the client is terminating\n\t\tfinWindow.removeEventListener(\"closed\", destructor);\n\t}\n\n\t// invoked when router init is complete\n\tfunction onReadyCallBack() {\n\t\tLogger.system.debug(\"RouterClient Ready: onReadyCallBack invoked\", self);\n\t\tisRouterReady = true;\n\n\t\t// invoke all the parent callbacks waiting for router to be ready\n\t\twhile (parentReadyCallbackQueue.length > 0) {\n\t\t\tLogger.system.debug(\"RouterClient parentReady invoked\");\n\t\t\tvar nextParentCallback = parentReadyCallbackQueue.shift();\n\t\t\tnextParentCallback();\n\t\t}\n\t}\n\n\t// called once on router-client creation\n\tfunction constructor(thisClientName, transportName) {\n\t\tclientName = thisClientName + \".\" + window.name;\n\t\tconsole.log(\"Router\", clientName);\n\t\tvar callbackCounter = 0;\n\n\t\tfin.desktop.main(function () { // wait for openfin to be ready\n\t\t\tif (callbackCounter++ === 0) { // this check should  not be needed; patch for OpenFin bug which invokes callback twice\n\t\t\t\t// catch \"window closing\" event so can cleanup\n\t\t\t\tvar finWindow = fin.desktop.Window.getCurrent();\n\t\t\t\twindow.addEventListener(\"unload\", destructor); // this is the correct event to catch but\n\t\t\t\tfinWindow.addEventListener(\"closed\", destructor); // this is the correct event to catch but currently doesn't work on mac\n\t\t\t\tConfigUtil.getExpandedRawManifest(function (manifest) {\n\t\t\t\t\tLogger.system.debug(\"Router getExpandedRawManifest\", manifest);\n\t\t\t\t\t//If manifest is a string, then there was an error getting the manifest because in a seperate application\n\t\t\t\t\tif (!manifest || typeof (manifest) === \"string\") {\n\t\t\t\t\t\tLogger.system.error(\"getExpandedRawManifest failed -- fatal error\", manifest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasyncConnectToEventRouter(manifest, clientName, transportName, onReadyCallBack); /**** establish connection to router service ****/\n\t\t\t\t\t}\n\t\t\t\t}, function (err) { Logger.system.error(err); });\n\t\t\t}\n\t\t});\n\t}\n\n\t// connects to event-router service\n\tfunction asyncConnectToEventRouter(manifest, clientName, transportName, onReadyCallBack) {\n\t\tvar transportNotSpecified = (typeof (transportName) === \"undefined\");\n\t\tvar myTimer;\n\t\tvar myRetryCounter = 0;\n\t\tvar isFinished = false;\n\n\t\tvar routerParams = {\n\t\t\trouterDomainRoot: manifest.finsemble.moduleRoot,\n\t\t\trouterSharedWorker: manifest.finsemble.moduleRoot + \"/common/routerSharedWorker.js\",\n\t\t\tforceRouterToOFB: manifest.finsemble.forceRouterToOFB\n\t\t};\n\t\tLogger.system.debug(\"RouterClient\", \"MANIFEST ROUTER PARMAS\", routerParams);\n\n\t\tif (transportNotSpecified) {\n\t\t\ttransport = RouterTransport.getRecommendedTransport(routerParams, incomingMessageHandler, clientName, \"RouterService\")\n\t\t\t\t.then(transportReady)\n\t\t\t\t.catch(errHandler);\n\t\t} else { // tranport specified...typically only for regression testing\n\t\t\ttransport = RouterTransport.getTransport(routerParams, transportName, incomingMessageHandler, clientName, \"RouterService\")\n\t\t\t\t.then(transportReady)\n\t\t\t\t.catch(errHandler);\n\t\t}\n\n\t\tfunction transportReady(transportObj) {\n\t\t\tLogger.system.debug(\"RouterClient: transport ready\", \"TRANSPORT OBJECT\", transportObj);\n\t\t\ttransport = transportObj;\n\t\t\thandshakeHandler = finished; // set function to receive handshake response\n\t\t\tsendHandshake();\n\t\t\tmyTimer = setInterval(sendHandshake, 250); // start time to retry if response not recieved back from router service\n\t\t}\n\n\t\tfunction sendHandshake() {\n\t\t\tLogger.system.debug(\"RouterClient: sendHandshake\");\n\t\t\tsendToRouterService(new InitialHandshakeMessage());\n\t\t\tif (myRetryCounter++ > 20) {\n\t\t\t\tLogger.system.error(\"RouterClient: failure to connect to router service\");\n\t\t\t\tclearInterval(myTimer);\n\t\t\t}\n\t\t}\n\n\t\tfunction finished(transportObj) {\n\t\t\tif (!isFinished) { // ensure only invoked once\n\t\t\t\tLogger.system.debug(\"RouterClient connected: starting \" + clientName + \" with transport \" + transport.identifier());\n\t\t\t\tisFinished = true;\n\t\t\t\tclearInterval(myTimer);\n\t\t\t\tif (queue) { // this should not happen with proper startup order, which waits on routerClient to be ready\n\t\t\t\t\tfor (var i = 0; i < queue.length; i++) {\n\t\t\t\t\t\tLogger.system.debug(\"RouterClient: firing queued msg\");\n\t\t\t\t\t\tvar msg = queue[i];\n\t\t\t\t\t\ttransport.send(msg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// notify initialization is complete\n\t\t\t\tif (onReadyCallBack) {\n\t\t\t\t\tonReadyCallBack();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction errHandler(errorMessage) {\n\t\t\tLogger.system.error(errorMessage);\n\t\t}\n\t}\n\n\t// provides unique id within one router client for queries\n\tfunction clientID() {\n\t\treturn clientName + \".\" + (++clientIDCounter);\n\t}\n\n\t// returns true if this routerClient originated the message\n\tfunction originatedHere() {\n\t\treturn this.header.origin === this.header.lastClient;\n\t}\n\n\t// invoke client callbacks in the input array (that are attached to a specific channel and listener type)\n\tfunction invokeListenerCallbacks(map, message) {\n\t\tvar clientCallbackArray = map[message.header.channel];\n\t\tif (clientCallbackArray === undefined) {\n\t\t\tLogger.system.warn(\"RouterClient: no listener for incoming transmit on channel \" + message.header.channel + \" from \" + message.header.origin, message);\n\t\t} else {\n\t\t\tmessage.originatedHere = originatedHere;// add local function to test origin\n\t\t\tfor (var i = 0; i < clientCallbackArray.length; i++) { // for each callback defined for the channel\n\t\t\t\tif (!Logger.isLogMessage(message.header.channel)) { // logger messages\n\t\t\t\t\tLogger.system.info(\"RouterClient: incoming transmit\", \"CHANNEL\", message.header.channel, \"FROM\", message.header.origin, \"MESSAGE\", message);\n\t\t\t\t}\n\t\t\t\tclientCallbackArray[i](null, message); // invoke the callback; the error parameter is always null for this case\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction sendQueryResponse(err, responseData) {\n\t\tLogger.system.info(\"RouterClient: outgoing query response\", \"RESPONSE DATA\", responseData, \"QUERY ID\", this.header.queryID);\n\t\tsendToRouterService(new QueryResponseMessage(this.header.queryID, err, responseData));\n\t}\n\n\t// invoke responder-listener callback (attached to a specific channel)\n\tfunction invokeResponderCallback(map, queryMessage) {\n\t\tvar responderCallback = map[queryMessage.header.channel];\n\t\tif (responderCallback === undefined) {\n\t\t\tLogger.system.warn(\"RouterClient: no query responder define on channel \" + queryMessage.header.channel + \" incoming from \" + queryMessage.header.origin, queryMessage);\n\t\t\tresponderCallback(null, queryMessage); // invoke the callback (no error), queryMessage);\n\t\t} else {\n\t\t\tif (!queryMessage.header.error) {\n\t\t\t\tqueryMessage.originatedHere = originatedHere; // add local function to test origin\n\t\t\t\tqueryMessage.sendQueryResponse = sendQueryResponse; // add callback function to message so responder can respond to query\n\t\t\t\tLogger.system.info(\"RouterClient: incoming query\", \"CHANNEL\", queryMessage.header.channel, \"FROM\", queryMessage.header.origin, \"QUERY MESSAGE\", queryMessage);\n\t\t\t\tresponderCallback(null, queryMessage); // invoke the callback (no error)\n\t\t\t} else { // invoke the callback with error since  flag in message (from router service)\n\t\t\t\tLogger.system.warn(\"RouterClient: queryResponder error\", queryMessage);\n\t\t\t\tresponderCallback(queryMessage.header.error, null);\n\t\t\t\tdelete map[queryMessage.header.channel]; // this is a bad responder (e.g. duplicate) so remove it\n\t\t\t}\n\t\t}\n\t}\n\n\t// add a callbackHandler into the query-response map for the given queryID\n\tfunction addQueryResponseCallBack(map, queryID, responseCallback) {\n\t\tmap[queryID] = responseCallback;\n\t}\n\n\t// add timer to wait for query response\n\tfunction addQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID, channel, timeout) {\n\t\tif (timeout > 0) {\n\t\t\tmapQueryResponseTimeOut[newQueryID] = setTimeout(function () {\n\t\t\t\tLogger.system.warn(\"RouterClient: timeout waiting on query response on channel \" + channel + \" for queryID \" + newQueryID +\n\t\t\t\t\t\" on timer \" + mapQueryResponseTimeOut[newQueryID] + \" timeout=\" + timeout);\n\t\t\t}, timeout);\n\t\t}\n\t}\n\n\t// delete timer waiting on query response (if it exists)\n\tfunction deleteQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID) {\n\t\tvar theTimer = mapQueryResponseTimeOut[newQueryID];\n\t\tif (theTimer !== undefined) {\n\t\t\tclearTimeout(theTimer);\n\t\t}\n\t}\n\n\t// invoke query-response callback (that is attached to a specific channel and listener type)\n\tfunction invokeQueryResponseCallback(map, responseMessage) {\n\t\tvar clientCallback = map[responseMessage.header.queryID];\n\t\tif (clientCallback === undefined) {\n\t\t\tLogger.system.warn(\"RouterClient: no handler for incoming query response\", \"QUERY ID\", responseMessage.header.queryID);\n\t\t} else {\n\t\t\t// delete any existing timer waiting on the response\n\t\t\tdeleteQueryResponseTimeout(mapQueryResponseTimeOut, responseMessage.header.queryID);\n\n\t\t\tif (!responseMessage.header.error) {\n\t\t\t\tLogger.system.info(\"RouterClient: incoming query response\", \"RESPONSE MESSAGE\", responseMessage, \"QUERY ID\", responseMessage.header.queryID);\n\t\t\t\tclientCallback(null, responseMessage); // invoke the callback passing the response message\n\t\t\t} else {\n\t\t\t\tLogger.system.warn(\"RouterClient: incoming queryResponse error\", responseMessage.header, \"QUERY ID\", responseMessage.header.queryID);\n\t\t\t\tclientCallback(responseMessage.header.error, responseMessage); // error from router service so pass it back instead of a message\n\t\t\t}\n\t\t\tdelete map[responseMessage.header.queryID];\n\t\t}\n\t}\n\n\t// add responder callbackHandler for the given channel\n\tfunction addResponderCallBack(map, channel, callback) {\n\t\tvar status = false;\n\t\tvar clientCallback = map[channel];\n\t\tif (clientCallback === undefined) {\n\t\t\tmap[channel] = callback;\n\t\t\tstatus = true;\n\t\t}\n\t\treturn status;\n\t}\n\n\t// support function for sendNotifyToSubscriber -- maintains local list of subscribers for pubsub responder\n\tfunction addToPubSubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\n\t\tif (!(topic in pubsubListOfSubscribers)) {\n\t\t\tpubsubListOfSubscribers[topic] = [subscribeID];\n\t\t} else {\n\t\t\tpubsubListOfSubscribers[topic].push(subscribeID);\n\t\t}\n\t}\n\n\t// support function for addPubSubResponder -- add pubsub responder callbackHandler for the given channel\n\tfunction addPubSubResponderCallBack(topic, subscribeCallback, publishCallback, unsubscribeCallback) {\n\t\tvar status = false;\n\t\tvar callbacks = mapPubSubResponders[topic.toString()];\n\t\tif (callbacks === undefined) {\n\t\t\tif (topic instanceof RegExp) {\n\t\t\t\tmapPubSubResponderRegEx[topic.toString()] = topic;\n\t\t\t\tLogger.system.info(\"RouterClient: PubSub RegEx added for topic \" + topic.toString()); // Note: topic may be a RegEx, so use toString() where applicable\n\t\t\t}\n\t\t\tmapPubSubResponders[topic.toString()] = { \"subscribeCallback\": subscribeCallback, \"publishCallback\": publishCallback, \"unsubscribeCallback\": unsubscribeCallback };\n\t\t\tstatus = true;\n\t\t}\n\t\treturn status;\n\t}\n\n\t// callback function for invokeSubscribePubSubCallback to notify new subscriber\n\tfunction sendNotifyToSubscriber(err, notifyData) {\n\t\tsendToRouterService(new NotifyMessage(this.header.subscribeID, this.header.topic, err, notifyData));\n\t\tif (!err) {\n\t\t\t// add new subscriber to list\n\t\t\taddToPubSubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\n\t\t\tLogger.system.info(\"RouterClient: incoming subscription added\", \"TOPIC\", this.header.topic, \"MESSAGE\", this);\n\t\t} else {\n\t\t\tLogger.system.info(\"RouterClient: incoming subscription rejected by pubsub responder\", \"TOPIC\", this.header.topic, \"MESSAGE\", this);\n\t\t}\n\t}\n\n\t// for incoming subscribe: invoke notify callback for pubsub responder\n\tfunction invokeSubscribePubSubCallback(subscribeMessage) {\n\t\tvar callbacks = mapPubSubResponders[subscribeMessage.header.topic];\n\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\n\t\t\tfor (var key in mapPubSubResponderRegEx) {\n\t\t\t\tif (mapPubSubResponderRegEx[key].test(subscribeMessage.header.topic)) {\n\t\t\t\t\tcallbacks = mapPubSubResponders[key];\n\t\t\t\t\tvar initialState = mapPubSubResponderState[subscribeMessage.header.topic]; // may already be initial state defined from publish\n\t\t\t\t\tif (initialState === undefined) { // if there isn't already state defined then use default from regEx\n\t\t\t\t\t\tinitialState = mapPubSubResponderState[key]; // initialize the state from RegEx topic\n\t\t\t\t\t}\n\t\t\t\t\tmapPubSubResponderState[subscribeMessage.header.topic] = initialState;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined) { // if still undefined\n\t\t\tLogger.system.warn(\"RouterClient: no pubsub responder defined for incoming subscribe\", subscribeMessage);\n\t\t} else {\n\t\t\tif (subscribeMessage.header.error) { // the router service uses the subscribe message in this case to return a pubsub error (ToDO: consider a generic error message)\n\t\t\t\tLogger.system.warn(\"RouterClient: pubsub error received from router service: \" + JSON.stringify(subscribeMessage.header.error));\n\t\t\t} else {\n\t\t\t\tsubscribeMessage.sendNotifyToSubscriber = sendNotifyToSubscriber; // add callback function to message so pubsub responder can respond with Notify message\n\t\t\t\tif (callbacks.subscribeCallback) {\n\t\t\t\t\tsubscribeMessage.data = mapPubSubResponderState[subscribeMessage.header.topic];\n\t\t\t\t\tcallbacks.subscribeCallback(null, subscribeMessage); // invoke the callback (no error)\n\t\t\t\t} else { // since no subscribe callback defined, use default functionality\n\t\t\t\t\tsubscribeMessage.sendNotifyToSubscriber(null, mapPubSubResponderState[subscribeMessage.header.topic]); // must invoke from message to set this properly\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// support function for removeSubscriber callback --  remove one subscribeID from array for the given subscription topic\n\tfunction removeFromPubSubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\n\t\tvar removed = false;\n\t\tif (topic in pubsubListOfSubscribers) {\n\t\t\tvar list = pubsubListOfSubscribers[topic];\n\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\tif (subscribeID === list[i]) {\n\t\t\t\t\tlist.splice(i, 1);\n\t\t\t\t\tif (list.length === 0) {\n\t\t\t\t\t\tdelete pubsubListOfSubscribers[topic];\n\t\t\t\t\t}\n\t\t\t\t\tremoved = true;\n\t\t\t\t\tLogger.system.info(\"RouterClient: PubSub removeListener\", \"TOPIC\", topic, \"FROM\", subscribeID);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!removed) {\n\t\t\tLogger.system.warn(\"RouterClient: tried to remove non-existance listener on \" + topic + \" from \" + JSON.stringify(subscribeID));\n\t\t}\n\t}\n\n\t// callback function for invokeUnsubscribePubSubCallback to remove the subscriber from the subscription\n\tfunction removeSubscriber() {\n\t\tremoveFromPubSubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\n\t}\n\n\t// for incoming unsubscribe: invoke unsubscribe callback for pubsub servier\n\tfunction invokeUnsubscribePubSubCallback(unsubscribeMessage) {\n\t\tvar callbacks = mapPubSubResponders[unsubscribeMessage.header.topic];\n\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\n\t\t\tfor (var key in mapPubSubResponderRegEx) {\n\t\t\t\tif (mapPubSubResponderRegEx[key].test(unsubscribeMessage.header.topic)) {\n\t\t\t\t\tcallbacks = mapPubSubResponders[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined) { // if still undefined\n\t\t\tLogger.system.warn(\"RouterClient: no pubsub responder defined for incoming unsubscribe\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n\t\t} else {\n\t\t\tunsubscribeMessage.removeSubscriber = removeSubscriber; // add callback function to message for pubsub responder (but must always remove)\n\t\t\tif (callbacks.unsubscribeCallback) {\n\t\t\t\tLogger.system.info(\"RouterClient: incoming unsubscribe callback\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n\t\t\t\tcallbacks.unsubscribeCallback(null, unsubscribeMessage); // invoke the callback (no error)\n\t\t\t} else { // since no unsubscribe callback defined, use default functionality\n\t\t\t\tLogger.system.info(\"RouterClient: incoming unsubscribe\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n\t\t\t\tunsubscribeMessage.removeSubscriber();\n\t\t\t}\n\t\t}\n\t}\n\n\t// callback function for invokePublishPubSubCallback to send Notify\n\tfunction sendNotifyToAllSubscribers(err, notifyData) {\n\t\tif (!err) {\n\t\t\tmapPubSubResponderState[this.header.topic] = notifyData; // store new state\n\t\t\tvar listOfSubscribers = pubsubListOfSubscribers[this.header.topic];\n\t\t\tif (typeof (listOfSubscribers) !== \"undefined\") { // confirm subscribers to send to, if none then nothing to do\n\t\t\t\tfor (var i = 0; i < listOfSubscribers.length; i++) {\n\t\t\t\t\tLogger.system.info(\"RouterClient: sending pubsub notify\", \"TOPIC\", this.header.topic, \"NOTIFY DATA\", notifyData);\n\t\t\t\t\tsendToRouterService(new NotifyMessage(listOfSubscribers[i], this.header.topic, err, notifyData));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.system.info(\"RouterClient: income publish rejected by pubsub responder\", err, notifyData);\n\t\t}\n\t}\n\n\t// for incoming Publish: invoke publish callback for pubsub servier\n\tfunction invokePublishPubSubCallback(publishMessage) {\n\t\tvar callbacks = mapPubSubResponders[publishMessage.header.topic];\n\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\n\t\t\tfor (var key in mapPubSubResponderRegEx) {\n\t\t\t\tif (mapPubSubResponderRegEx[key].test(publishMessage.header.topic)) {\n\t\t\t\t\tcallbacks = mapPubSubResponders[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined) { // if still undefined\n\t\t\tLogger.system.warn(\"RouterClient: no pubsub responder defined for incoming publish\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n\t\t} else {\n\t\t\tpublishMessage.sendNotifyToAllSubscribers = sendNotifyToAllSubscribers; // add callback function to message so pubsub responder can respond to publish\n\t\t\tif (callbacks.publishCallback) {\n\t\t\t\tLogger.system.info(\"RouterClient: incoming PubSub publish callback invoked\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n\t\t\t\tcallbacks.publishCallback(null, publishMessage); // invoke the callback (no error)\n\t\t\t} else { // since no pubish callback defined, use default functionality\n\t\t\t\tLogger.system.info(\"RouterClient: incoming PubSub publish\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n\t\t\t\tpublishMessage.sendNotifyToAllSubscribers(null, publishMessage.data); // must call from publish message (like a callback) so 'this' is properly set\n\t\t\t}\n\t\t}\n\t}\n\n\t// for incoming Notify: invoke notify callback (that are attached to a specific channel and listener type)\n\tfunction invokeNotifyCallback(mapSubscribersID, notifyMessage) {\n\t\tvar notifyCallback = mapSubscribersID[notifyMessage.header.subscribeID];\n\t\tif (notifyCallback === undefined) {\n\t\t\tLogger.system.warn(\"RouterClient: no subscription handler defined for incoming notify for subscriberID\", notifyMessage.header.subscribeID, notifyMessage);\n\t\t} else {\n\t\t\tif (!notifyMessage.header.error) {\n\t\t\t\tnotifyMessage.originatedHere = originatedHere;// add local function to test origin\n\t\t\t\tLogger.system.info(\"RouterClient: incoming PubSub notify\", \"SUBSCRIBER ID\", notifyMessage.header.subscribeID, \"NOTIFY MESSAGE\", notifyMessage);\n\t\t\t\tnotifyCallback(null, notifyMessage); // invoke the callback passing the response message\n\t\t\t} else {\n\t\t\t\tLogger.system.info(\"RouterClient: incoming PubSub notify error for subscriberID\", \"SUBSCRIBER ID\", notifyMessage.header.subscribeID, \"NOTIFY MESSAGE\", notifyMessage);\n\t\t\t\tnotifyCallback(notifyMessage.header.error, notifyMessage); // error from router service so pass it back instead of a message\n\t\t\t}\n\t\t}\n\t}\n\n\t// outgoing Unsubscribe: remove subscriber callbackHandler for the given channel\n\tfunction removeSubscriberCallBack(mapSubscribersID, subscribeID) {\n\t\tvar status = false;\n\t\tvar notifyCallback = mapSubscribersID[subscribeID];\n\t\tif (notifyCallback !== undefined) {\n\t\t\tdelete mapSubscribersID[subscribeID];\n\t\t\tstatus = true;\n\t\t}\n\t\treturn status;\n\t}\n\n\t// for outgoing addSubscriber -- add a callback Handler for the subscribe\n\tfunction addSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic) {\n\t\tmapSubscribersID[subscribeID] = notifyCallback;\n\t\tmapSubscribersTopic[subscribeID] = topic;\n\n\t}\n\n\t// for removePubSubResponder: remove responder callbackHandler for the given channel\n\tfunction removeResponderCallBack(map, channel) {\n\t\tvar status = false;\n\t\tvar clientCallback = map[channel];\n\t\tif (clientCallback !== undefined) {\n\t\t\tdelete map[channel];\n\t\t\tstatus = true;\n\t\t}\n\t\treturn status;\n\t}\n\n\t// for addListener: add a callbackHandler into the specified map (which depends on listener type) for the given channel\n\tfunction addListenerCallBack(map, channel, callback) {\n\t\tvar firstChannelClient = false;\n\t\tvar clientCallbackArray = map[channel];\n\t\tif (clientCallbackArray === undefined || clientCallbackArray.length === 0) {\n\t\t\tmap[channel] = [callback];\n\t\t\tfirstChannelClient = true;\n\t\t} else {\n\t\t\tclientCallbackArray.push(callback);\n\t\t}\n\t\treturn firstChannelClient;\n\t}\n\n\t// for removeListener: remove a callbackHandler from the specified map (which depends on listener type) for the given channel\n\tfunction removeListenerCallBack(map, channel, callback) {\n\t\tvar lastChannelClient = false;\n\t\tvar clientCallbackArray = map[channel];\n\t\tif (clientCallbackArray !== undefined) {\n\t\t\tvar index = clientCallbackArray.indexOf(callback);\n\t\t\tif (index > -1) {\n\t\t\t\tclientCallbackArray.splice(index, 1);\n\t\t\t\tif (clientCallbackArray.length === 0) {\n\t\t\t\t\tlastChannelClient = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLogger.system.warn(\"no listener defined for channel: \" + channel);\n\t\t\t}\n\t\t}\n\t\treturn lastChannelClient;\n\t}\n\n\t// route incoming message to appropriate callback, which depends on the message type and channel\n\tfunction routeIncomingMessage(incomingMessage) {\n\t\tLogger.system.verbose(\"Incoming Message Type\", incomingMessage.header.type, incomingMessage);\n\t\tswitch (incomingMessage.header.type) {\n\t\tcase \"transmit\":\n\t\t\tinvokeListenerCallbacks(mapListeners, incomingMessage);\n\t\t\tbreak;\n\t\tcase \"query\":\n\t\t\tinvokeResponderCallback(mapResponders, incomingMessage);\n\t\t\tbreak;\n\t\tcase \"queryResponse\":\n\t\t\tinvokeQueryResponseCallback(mapQueryResponses, incomingMessage);\n\t\t\tbreak;\n\t\tcase \"notify\":\n\t\t\tinvokeNotifyCallback(mapSubscribersID, incomingMessage);\n\t\t\tbreak;\n\t\tcase \"publish\":\n\t\t\tinvokePublishPubSubCallback(incomingMessage);\n\t\t\tbreak;\n\t\tcase \"subscribe\":\n\t\t\tinvokeSubscribePubSubCallback(incomingMessage);\n\t\t\tbreak;\n\t\tcase \"unsubscribe\":\n\t\t\tinvokeUnsubscribePubSubCallback(incomingMessage);\n\t\t\tbreak;\n\t\tcase \"timeCalibration\":\n\t\t\ttimeCalibrationHandler(incomingMessage);\n\t\t\tbreak;\n\t\tcase \"initialHandshakeResponse\":\n\t\t\thandshakeHandler();\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\t}\n\n\t// *** all incoming messages from underlying transport arrive here ***\n\t// although incoming transport information is available, it is not passed on because not needed\n\tfunction incomingMessageHandler(incomingTransportInfo, message) {\n\t\t// ToDo: good place to put a function to validate incoming message/data\n\t\tmessage.header.lastClient = clientName; // add last client for diagnostics\n\t\tmessage.header.incomingTransportInfo = incomingTransportInfo;\n\t\trouteIncomingMessage(message);\n\t}\n\n\t// *** all outbound messages exit here though the appropriate transport ***\n\tfunction sendToRouterService(message) {\n\t\tLogger.system.verbose(\"Outgoing Message\", message.header.type, message);\n\t\tif (!transport || (transport instanceof Promise)) {\n\t\t\tLogger.system.warn(\"RouterClient: Queuing message since router initialization not complete\", message);\n\t\t\tqueue.push(message);\n\t\t} else {\n\t\t\ttransport.send(message);\n\t\t}\n\t}\n\n\n\t/////////////////////////////////////////////\n\t// Public Functions -- The Router Client API\n\t/////////////////////////////////////////////\n\n\t/**\n\t * Get router client name.\n\t *\n\t * @param {string} newClientName string identify the client\n\t * FSBL.Clients.RouterClient.setClientName(\"MyComponent\");\n\t * @private\n\t */\n\tthis.getClientName = function () {\n\t\tLogger.system.debug(\"RouterClient.getClientName\", clientName);\n\t\treturn clientName;\n\t};\n\n\t/**\n\t * Checks if router is ready. May be invoked multiple times. Invokes cb when ready, which may be immediately.  Router is not ready until underlying transport to router service is ready.\n\t *\n\t * @param {function} cb callback function to invoke when router is ready\n\t */\n\tthis.onReady = function (cb) {\n\t\tValidate.args(cb, \"function\");\n\t\tif (isRouterReady) {\n\t\t\tLogger.system.debug(\"Router Ready: invoking parentReady callback\");\n\t\t\tcb();\n\t\t} else {\n\t\t\tLogger.system.debug(\"Router Ready: queuing parentReady callback\");\n\t\t\tparentReadyCallbackQueue.push(cb);\n\t\t}\n\t};\n\n\t/**\n\t * Estimates offset to align the reference time with Router Service.  Does this by exchanging messages with RouterService, getting the service's time, and estimating communication delay.\n\t *\n\t * @private\n\t */\n\tthis.calibrateTimeWithRouterService = function (callback) {\n\t\tconst TARGET_HANDSHAKE_COUNT = 5;\n\t\tvar handshakeCounter = 0;\n\t\tvar timeOffset;\n\t\tvar offsetForFastest;\n\t\tvar fastestRRT = Infinity;\n\n\t\tfunction calibrationCalculation(finalHandshakeMessage) {\n\t\t\tvar timeOffset = 0;\n\t\t\tfor (var i = 1; i < TARGET_HANDSHAKE_COUNT; i++) {\n\t\t\t\tvar startClientTime = finalHandshakeMessage.clientBaseTime[i - 1];\n\t\t\t\tvar stopClientTime = finalHandshakeMessage.clientBaseTime[i];\n\t\t\t\tvar rtt = stopClientTime - startClientTime; // round-trip time\n\t\t\t\tvar serviceTime = finalHandshakeMessage.serviceBaseTime[i - 1];\n\t\t\t\tvar offset = serviceTime - (startClientTime + (rtt / 2));\n\t\t\t\tif (rtt < fastestRRT) {\n\t\t\t\t\tfastestRRT = rtt;\n\t\t\t\t\toffsetForFastest = offset;\n\t\t\t\t}\n\t\t\t\ttimeOffset += offset;\n\t\t\t\tLogger.system.debug(\"calibrationCalculation Intermediate Values\", \"lastRRT\", rtt, \"lastOffset\", offset, \"fastestOffset\", offsetForFastest, \"fastestRRT\", fastestRRT);\n\t\t\t}\n\t\t\ttimeOffset /= (TARGET_HANDSHAKE_COUNT - 1);\n\t\t\tLogger.system.debug(\"RouterClient calibrationCalculation\", \"Average Offset\", timeOffset, \"Choosen FastestOffset\", offsetForFastest, finalHandshakeMessage);\n\t\t\tcallback(offsetForFastest); // use the offset with the shortest RTT since it is often the most accurate\n\t\t}\n\n\t\tfunction timeCalibrationHandlerFunction(message) {\n\t\t\thandshakeCounter++;\n\t\t\tif (handshakeCounter > TARGET_HANDSHAKE_COUNT) {\n\t\t\t\tcalibrationCalculation(message); // enough handshake data gather, so do the calibration\n\t\t\t} else {\n\t\t\t\tmessage.clientBaseTime.push(window.performance.timing.navigationStart + window.performance.now());\n\t\t\t\tsendToRouterService(new TimeCalibrationHandshakeMessage(message.clientBaseTime, message.serviceBaseTime));\n\t\t\t}\n\t\t}\n\n\t\ttimeCalibrationHandler = timeCalibrationHandlerFunction; // used in routeIncomingMessage to route handshake response back to handler\n\t\ttimeCalibrationHandler(new TimeCalibrationHandshakeMessage([], [])); // invoke first time to start exchanging handshakes; will be invoked each time handshake message received back from FouterService\n\t};\n\n\t/**\n\t * Backward compatibility?\n\t */\n\tthis.ready = this.onReady;\n\t/**\n\t * Add listener for incoming transmit events on specified channel. Each of the incoming events will trigger the specified event handler. The number of listeners is not limited (either local to this Finsemble window or in a seperate Finsemble window).\n\t *\n\t * See [transmit]{@link RouterClientConstructor#transmit} for sending a cooresponding event message to listener. See [removeListener]{@link RouterClientConstructor#removeListener} to remove the listener.\n\t *\n\t * @param {string} channel any unique string to identify the channel (must match correspond transmit channel name)\n\t * @param {function} eventHandler function (see example below)\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.addListener(\"SomeChannelName\", function (error, response) {\n\t\t\tif (error) {\n\t\t\t\tLogger.system.log(\"ChannelA Error: ' + JSON.stringify(error));\n\t\t\t} else {\n\t\t\t\tvar data = response.data;\n\t\t\t\tLogger.system.log(\"ChannelA Response: ' + JSON.stringify(response));\n\t\t\t}\n\t * });\n\t *\n\t */\n\tthis.addListener = function (channel, eventHandler) {\n\t\tLogger.system.info(\"RouterClient.addListener\", \"CHANNEL\", channel);\n\t\tValidate.args(channel, \"string\", eventHandler, \"function\");\n\t\tvar firstChannelClient = addListenerCallBack(mapListeners, channel, eventHandler);\n\t\tif (firstChannelClient) {\n\t\t\tsendToRouterService(new AddListenerMessage(channel));\n\t\t}\n\t};\n\n\t/**\n\t * Transmit event to all listeners on the specified channel. If no listeners the event is discarded without error. All listeners to the channel in this Finsemble window and other Finsemble windows will receive the transmit.\n\t *\n\t * See [addListener]{@link RouterClientConstructor#addListener} to add a listener to receive the transmit.\n\t *\n\t * @param {string} toChannel any unique string to identify the channel (must match correspond listener channel name)\n\t * @param {any} event any object or primitive type to be transmitted\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.transmit(\"SomeChannelName\", event);\n\t *\n\t */\n\tthis.transmit = function (toChannel, event) {\n\t\tif (!Logger.isLogMessage(toChannel)) { // logger messages\n\t\t\tLogger.system.info(\"RouterClient.transmit\", \"TO CHANNEL\", toChannel, \"EVENT\", event);\n\t\t}\n\t\tValidate.args(toChannel, \"string\", event, \"any\");\n\t\tsendToRouterService(new TransmitMessage(toChannel, event));\n\t};\n\n\t/**\n\t * Remove event listener from specified channel for the specific event handler (only listeners created locally can be removed).\n\t *\n\t * See [addListener]{@link RouterClientConstructor#addListener} for corresponding add of a listener.\n\t *\n\t * @param {string} channel unique channel name to remove listener from\n\t * @param {function} eventHandler function used for the event handler when the listener was added\n\t */\n\tthis.removeListener = function (channel, eventHandler) {\n\t\tLogger.system.info(\"RouterClient.removelistener\", \"CHANNEL\", channel, \"EVENT HANDLER\", eventHandler);\n\t\tValidate.args(channel, \"string\", eventHandler, \"function\");\n\t\tvar lastChannelListener = removeListenerCallBack(mapListeners, channel, eventHandler);\n\t\tif (lastChannelListener) {\n\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\n\t\t}\n\t};\n\n\t/**\n\t * Add query responder to the specified channel (only one responder allowed per channel within the Finsemble application). The responder's queryEventHander function will receive all incoming queries for the specified channel (whether from this Finsemble window or remote Finsemble windows).\n\t *\n\t * See [query]{@link RouterClientConstructor#query} for sending a corresponding query-event message to this responder.\n\t *\n\t * @param {string} channel any unique string to identify the channel (must match correspond query channel name); only one responder allower per channel\n\t * @param {function} queryEventHandler function to handle the incoming query (see example below); note incoming queryMessage contains function to send response\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.addResponder(\"ResponderChannelName\", function (error, queryMessage) {\n\t *\tif (error) {\n\t *\t\tLogger.system.log('addResponder failed: ' + JSON.stringify(error));\n\t *\t} else {\n\t *\t\t// process income query message\n\t *\t\tqueryMessage.sendQueryResponse(null, queryMessage.data); // A QUERY RESPONSE MUST BE SENT\n\t *\t}\n\t * });\n\t *\n\t */\n\tthis.addResponder = function (channel, queryEventHandler) {\n\t\tLogger.system.info(\"RouterClient.addResponder\", \"CHANNEL\", channel);\n\t\tValidate.args(channel, \"string\", queryEventHandler, \"function\");\n\t\tvar status = addResponderCallBack(mapResponders, channel, queryEventHandler);\n\t\tif (status) {\n\t\t\tsendToRouterService(new addResponderMessage(channel));\n\t\t} else {\n\t\t\tLogger.system.warn(\"RouterClient.addResponder: Responder already locally defined for channel \" + channel);\n\t\t\tqueryEventHandler({\n\t\t\t\t\"RouteClient QueryError\": \"Responder already locally defined for channel\"\n\t\t\t}, null); // immediately invoke callback passing error\n\t\t}\n\t};\n\n\t/**\n\t * Send a query to responder listening on specified channel. The responder may be in this Finsemble window or another Finsemble window.\n\t *\n\t * See [addResponder]{@link RouterClientConstructor#addResponder} to add a responder to receive the query.\n\t *\n\t * @param {any} responderChannel any unique string to identify the channel (must match correspond responder channel name)\n\t * @param {object} queryEvent event message sent to responder\n\t * @param {any=} params this object currently can carry only a timeout value (e.g. { timeout: 3000 }) for a query-response timer.  Timer defaults to 5000 milliseconds is no params value is passed in.  A timer is set only when timeout > 0. If the timer expires, only a warning message is display for diagnostics.\n\t * @param {function} responseEventHandler event handler to receive in query response (sent from the responder for the specified channel)\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.query(\"someChannelName\", {}, function (error, queryResponseMessage) {\n\t *\tif (error) {\n\t *\t\tLogger.system.log('query failed: ' + JSON.stringify(error));\n\t *\t} else {\n\t *\t\t// process income query response message\n\t *\t\tvar responseData = queryResponseMessage.data;\n\t *\t\tLogger.system.log('query response: ' + JSON.stringify(queryResponseMessage));\n\t *\t}\n\t * });\n\t *\n\t * FSBL.Clients.RouterClient.query(\"someChannelName\", { queryKey: \"abc123\"}, { timeout: 1000 }, function (error, queryResponseMessage) {\n\t *\tif (!error) {\n\t *\t\t// process income query response message\n\t *\t\tvar responseData = queryResponseMessage.data;\n\t *\t}\n\t * }); */\n\tthis.query = function (responderChannel, queryEvent, params, responseEventHandler) {\n\t\tvar newQueryID = clientID();\n\t\tvar timestamp = window.performance.timing.navigationStart + window.performance.now();\n\t\tvar navstart = window.performance.timing.navigationStart;\n\t\tvar timenow = window.performance.now(); // these timer values used for logging diagnostices\n\n\t\tLogger.system.info(\"RouterClient.query\", \"RESPONDER CHANNEL\", responderChannel, \"QUERY EVENT\", queryEvent, \"PARAMS\", params, \"QUERYID\", newQueryID, { timestamp, navstart, timenow });\n\t\tif (arguments.length === 3) {\n\t\t\tresponseEventHandler = params;\n\t\t\tparams = { timeout: 5000 };\n\t\t}\n\t\tValidate.args(responderChannel, \"string\", queryEvent, \"any=\", params, \"object=\", responseEventHandler, \"function\");\n\t\tparams = params || {};\n\t\tValidate.args2(\"params.timeout\", params.timeout, \"number\");\n\n\t\taddQueryResponseCallBack(mapQueryResponses, newQueryID, responseEventHandler);\n\t\taddQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID, responderChannel, params.timeout);\n\t\tsendToRouterService(new QueryMessage(newQueryID, responderChannel, queryEvent));\n\t};\n\n\t/**\n\t * Remove query responder from specified channel. Only a locally added responder can be removed (i.e. a responder defined in the same component or service).\n\t *\n\t * See [addResponder]{@link RouterClientConstructor#addResponder} for corresponding add of a query responder.\n\t *\n\t * @param {string} responderChannel string identifying the channel to remove responder from\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.removeResponder(\"someChannelName\");\n\t *\n\t */\n\tthis.removeResponder = function (responderChannel) {\n\t\tLogger.system.info(\"RouterClient.removeResponder\", \"RESPONDER CHANNEL\", responderChannel);\n\t\tValidate.args(responderChannel, \"string\");\n\t\tvar status = removeResponderCallBack(mapResponders, responderChannel);\n\t\tif (status) {\n\t\t\tsendToRouterService(new RemoveResponderMessage(responderChannel));\n\t\t}\n\t};\n\n\t/**\n\t * Add a PubSub responder for specified topic. All subscribes and publishes to the topic will comes to responder (whether from local window or another window). Only one PubSub responder allowed per topic value in Finsemble application; however, the topic value may be a regular-expression representing a set of related topics, in which case the PubSub responder will responder to all matching topics. When a regEx topic is used, the same default functionality is provides for each matching topic -- the difference is only one PubSub responder is needed to cover a set of related topics, plus the same callback handers can be used (if provided).\n\t *\n\t * All the callback function are optional because each PubSub responder comes with build-in default functionality (described below).\n\t *\n\t * Note an exact topic match will take precedence over a regEx match, but otherwise results are unpredictable for overlapping RegEx topics.\n\t *\n\t * See [subscribe]{@link RouterClientConstructor#subscribe} and [publish]{@link RouterClientConstructor#publish} for corresponding functions sending to the PubSub responder.\n\t *\n\t * @param {string} topic unique topic for this responder, or a topic RegEx (e.g. '/abc.+/') to handle a set of topics\n\t * @param {object} initialState initial state for the topic (defaults to empty struct); can be any object\n\t * @param {object=} params optional parameters\n\t * @param {function=} params.subscribeCallback allows responder know of incoming subscription and accept or reject it (default is to accept)\n\t * @param {function=} params.publishCallback allows responder to use the publish data to form a new state (default is the publish data becomes the new state)\n\t * @param {function=} params.unsubscribeCallback allows responder to know of the unsubscribe, but it must be accepted (the default accepts)\n\t * @param {function=} callback optional callback(err,res) function. If addPubSubResponder failed then err set; otherwise, res set to \"success\"\n\t *\n\t * @example\n\t *\n\t * function subscribeCallback(error, subscribe) {\n\t * \tif (subscribe) {\n\t * \t\t// must make this callback to accept or reject the subscribe (default is to accept). First parm is err and second is the initial state\n\t * \t\tsubscribe.sendNotifyToSubscriber(null, { \"NOTIFICATION-STATE\": \"One\" });\n\t * \t}\n\t * }\n\t * function publishCallback(error, publish) {\n\t * \tif (publish) {\n\t * \t\t// must make this callback to send notify to all subscribers (if error parameter set then notify will not be sent)\n\t * \t\tpublish.sendNotifyToAllSubscribers(null, publish.data);\n\t * \t}\n\t * }\n\t * function unsubscribeCallback(error, unsubscribe) {\n\t * \tif (unsubscribe) {\n\t * \t\t// must make this callback to acknowledge the unsubscribe\n\t * \t\tunsubscribe.removeSubscriber();\n\t * \t}\n\t * }\n\t * FSBL.Clients.RouterClient.addPubSubResponder(\"topicABC\", { \"State\": \"start\" },\n\t * \t{\n\t * \t\tsubscribeCallback:subscribeCallback,\n\t * \t\tpublishCallback:publishCallback,\n\t * \t\tunsubscribeCallback:unsubscribeCallback\n\t * \t});\n\t *\n\t *   or\n\t *\n\t * FSBL.Clients.RouterClient.addPubSubResponder(\"topicABC\", { \"State\": \"start\" });\n\t *\n\t *   or\n\t *\n\t * FSBL.Clients.RouterClient.addPubSubResponder(\\/topicA*\\/, { \"State\": \"start\" });\n\t *\n\t */\n\tthis.addPubSubResponder = function (topic, initialState, params, callback) {\n\t\tvar error;\n\t\tvar response;\n\t\tLogger.system.info(\"RouterClient.addPubSubResponder\", \"TOPIC\", topic, \"INITIAL STATE\", initialState, \"PARAMS\", params);\n\t\tValidate.args(topic, \"any\", initialState, \"object=\", params, \"object=\");\n\t\tparams = params || {};\n\t\tValidate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\n\t\t\tValidate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\n\n\t\tvar status = addPubSubResponderCallBack(topic, params.subscribeCallback, params.publishCallback, params.unsubscribeCallback);\n\t\tif (status) {\n\t\t\tinitialState = initialState || {};\n\t\t\tmapPubSubResponderState[topic.toString()] = Utils.clone(initialState);\n\t\t\tsendToRouterService(new AddPubSubResponderMessage(topic.toString()));\n\t\t\tresponse = \"success\";\n\t\t} else {\n\t\t\terror = \"RouterClient.addPubSubResponder: Responder already locally defined for topic \" + topic;\n\t\t\tLogger.system.warn(error);\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback(error, response);\n\t\t}\n\t};\n\n\t/**\n\t * Remove pubsub responder from specified topic. Only locally created responders (i.e. created in local window) can be removed.\n\t *\n\t * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder.\n\t *\n\t * @param {string} topic unique topic for responder being removed (may be RegEx, but if so much be exact regEx used previously with addPubSubResponder)\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.removePubSubResponder(\"topicABC\");\n\t *\n\t */\n\tthis.removePubSubResponder = function (topic) {\n\t\tLogger.system.info(\"RouterClient.removePubSubResponder\", \"TOPIC\", topic);\n\t\tValidate.args(topic, \"any\");\n\t\tvar status = removeResponderCallBack(mapPubSubResponders, topic);\n\t\tif (status) {\n\t\t\tdelete mapPubSubResponderState[topic.toString()]; // remove corresponding state\n\t\t\tdelete mapPubSubResponderRegEx[topic.toString()]; // may be a RegEx\n\t\t\tsendToRouterService(new RemovePubSubResponderMessage(topic));\n\t\t} else {\n\t\t\tLogger.system.warn(\"RouterClient.removePubSubResponder failed: Could not find responder for topic \" + topic);\n\t\t}\n\t};\n\n\t/**\n\t * Subscribe to a PubSub Responder. Each responder topic can have many subscribers (local in this window or remote in other windows). Each subscriber immediately (but asyncronouly) receives back current state in a notify; new notifys are receive for each publish sent to the same topic.\n\t *\n\t * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder to handle the subscribe. See [publish]{@link RouterClientConstructor#publish} for corresponding publish to notify the subscriber.\n\t *\n\t * @param {string} topic topic being subscribed to\n\t * @param {function} notifyCallback invoked for each income notify for the given topic (i.e. initial notify plus for each publish)\n\t * @returns subscribe-id object optionally used for unsubscribing later\n\t *\n\t * @example\n\t *\n\t * var subscribeId = RouterClient.subscribe(\"topicABC\", function(err,notify) {\n\t *\t\tif (!err) {\n\t *\t\t\tvar notificationStateData = notify.data;\n\t *\t\t\t// do something with notify data\n\t *  \t}\n\t * });\n\t *\n\t */\n\tthis.subscribe = function (topic, notifyCallback) {\n\t\tLogger.system.info(\"RouterClient.subscribe\", \"TOPIC\", topic);\n\t\tValidate.args(topic, \"string\", notifyCallback, \"function\");\n\t\tvar subscribeID = clientID();\n\t\taddSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic);\n\t\tsendToRouterService(new SubscribeMessage(subscribeID, topic));\n\t\treturn { \"subscribeID\": subscribeID, \"topic\": topic };\n\t};\n\n\t/**\n\t * Publish to a PubSub Responder, which will trigger a corresponding Notify to be sent to all subscribers (local in this window or remote in other windows). There can be multiple publishers for a topic (again, in same window or remote windows)\n\t *\n\t * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder to handle the publish (i.e. sending notifications to all subscriber). See [Subscribe]{@link RouterClientConstructor#addPubSubResponder} for corresponding subscription to receive publish results (in the form of a notify event)\n\t *\n\t * @param {string} topic topic being published to\n\t * @param {object} event topic state to be published to all subscriber (unless the SubPub responder optionally modifies in between)\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.publish(\"topicABC\", topicState);\n\t *\n\t */\n\tthis.publish = function (topic, event) {\n\t\tLogger.system.info(\"RouterClient.publish\", \"TOPIC\", topic, \"EVENT\", event);\n\t\tValidate.args(topic, \"string\", event, \"any\");\n\t\tsendToRouterService(new PublishMessage(topic, event));\n\t};\n\n\t/**\n\t * Unsubscribe from PubSub responder so no more notifications received (but doesn't affect other subscriptions). Only works from the window the PubSub responder was created in.\n\t *\n\t * See [subscribe]{@link RouterClientConstructor#subscribe} for corresponding subscription being removed.\n\t *\n\t * @param {object} subscribeID the id return from the corresponding subscribe for the topic\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.unsubscribe(subscribeId);\n\t *\n\t */\n\tthis.unsubscribe = function (subscribeIDStruct) {\n\t\tLogger.system.info(\"RouterClient.unsubscribe\", \"SUBSCRIBE ID\", subscribeIDStruct);\n\t\tValidate.args(subscribeIDStruct, \"object\") && Validate.args2(\"subscribeIDStruct.subscribeID\", subscribeIDStruct.subscribeID, \"string\");\n\t\tvar deletedSubscriber = removeSubscriberCallBack(mapSubscribersID, subscribeIDStruct.subscribeID);\n\t\tif (deletedSubscriber) {\n\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeIDStruct.subscribeID, subscribeIDStruct.topic));\n\t\t} else {\n\t\t\tLogger.system.warn(\"RouterClient.unsubscribe: Could not find subscribeID for topic \" + subscribeIDStruct.topic);\n\t\t}\n\t};\n\n\t/**\n\t * Test an incoming router message to see if it originated from the same origin (e.g. a trusted source...not cross-domain). Currently same origin is known only because a sharedWorker transport is used (by definition SharedWorkers do not work cross-domain).  This means any message coming in over the OpenFin IAB will not be trusted; however, by default all same-origin components and services connect to the router using a SharedWorker transport.\n\t *\n\t * @param {object} incomingMessage an incoming router message (e.g. transmit, query, notification) to test to see if trusted.\n\t *\n\t * @returns true if message is same origin (i.e. received over SharedWorker transport).\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.trustedMessage(incomingRouterMessage);\n\t *\n\t */\n\tthis.trustedMessage = function (incomingMessage) {\n\t\tvar isTrusted = false;\n\t\tLogger.system.debug(\"RouterClient.trustedMessage\", incomingMessage);\n\t\tif (incomingMessage.header.incomingTransportInfo.transportID === \"SharedWorker\") {\n\t\t\tisTrusted = true;\n\t\t}\n\t\treturn isTrusted;\n\t};\n\n\t/*\n\t * @TODO: consider adding disconnectAllListerns(), disconnectAllResponders(), disconnectAllSubscribers()\n\t*/\n\n\t/**\n\t * Removes all listeners, responders, and subscribers for this router client -- automatically called when client is shutting down. Can be called multiple times.\n\t */\n\tthis.disconnectAll = function () {\n\t\tLogger.system.info(\"RouterClient.disconnectAll\");\n\t\tfor (var channel in mapListeners) {\n\t\t\tLogger.system.debug(\"RouterClient.disconnectAll is removing listener on \" + channel);\n\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\n\t\t\tdelete mapListeners[channel];\n\t\t}\n\n\t\tfor (var responderChannel in mapResponders) {\n\t\t\tLogger.system.debug(\"RouterClient.disconnectAll is removing responder on \" + responderChannel);\n\t\t\tsendToRouterService(new RemoveResponderMessage(responderChannel));\n\t\t\tdelete mapResponders[responderChannel];\n\t\t}\n\n\t\tfor (var topic in mapPubSubResponders) {\n\t\t\tLogger.system.debug(\"RouterClient.disconnectAll is removing pubsub responder on \" + topic);\n\t\t\tsendToRouterService(new RemovePubSubResponderMessage(topic));\n\t\t\tdelete mapPubSubResponders[topic.toString()]; // could be a RegEx\n\t\t\tdelete mapPubSubResponderState[topic.toString()]; // remove corresponding state\n\t\t\tdelete mapPubSubResponderRegEx[topic.toString()]; // may be a RegEx\n\t\t}\n\n\t\tfor (var subscribeID in mapSubscribersID) {\n\t\t\tvar stopic = mapSubscribersTopic[subscribeID];\n\t\t\tLogger.system.debug(\"RouterClient.disconnectAll is removing subscriber on \" + stopic);\n\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeID, stopic));\n\t\t\tdelete mapSubscribersID[subscribeID];\n\t\t\tdelete mapSubscribersTopic[subscribeID];\n\t\t}\n\t};\n\n\tconstructor(thisClientName, transportName); // on creation invoke to initialize\n};\n\nmodule.exports = RouterClientConstructor;\n\n\n\n// WEBPACK FOOTER //\n// src/clients/routerClientConstructor.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\nvar FSBLUtils = require(\"./util\");\nvar Logger = require(\"../clients/logger\");\n\nvar ConfigUtil = {\n\t/**\n\t * @introduction\n\t * <h2>Finsemble Configuration Utility Functions</h2>\n\t * @private\n\t * @class ConfigUtil\n\t */\n\t// run through the configuration object and resolve any variables definitions (i.e. $applicationRoot)\n\tresolveConfigVariables(finsembleConfig, startingConfigObject) {\n\t\tvar pass = 0;\n\t\tvar needsAnotherPass = true;\n\n\t\t// resolve a variable within a config string\n\t\tfunction resolveString(configString) {\n\t\t\tvar seperators = /[/\\\\:?=&]/; // list of seperators in regex form (will add other seperators if needed)\n\t\t\tvar tokens = configString.split(seperators);\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tif (tokens[i][0] === \"$\") { // special variable character $ has to first char in string\n\t\t\t\t\tvar variableReference = tokens[i].substring(1); // string off the leading $\n\t\t\t\t\tvar variableResolution = finsembleConfig[variableReference]; // the variable value is another config property, which already must be set\n\t\t\t\t\tvar newValue = configString.replace(tokens[i], variableResolution); // replace the variable reference with new value\n\t\t\t\t\tLogger.system.verbose(\"resolveString configString\", tokens[i], variableReference, variableResolution, \"oldvalue=\", configString, \"value=\", newValue);\n\t\t\t\t\tneedsAnotherPass = true; // <<-- here is the only place needsAnotherPass is set, since still resolving variables\n\t\t\t\t\tconfigString = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (configString);\n\t\t}\n\n\t\t// process an array of config items looking for variables to resolve (a recursive routine)\n\t\tfunction resolveArray(configArray, pass, recursionLevel) {\n\t\t\tLogger.system.verbose(\"resolveArray\", \"pass\", pass, \"recursionLevel\", recursionLevel, \"configArray:\", configArray);\n\t\t\tfor (var i = 0; i < configArray.length; i++) {\n\t\t\t\tvar value = configArray[i];\n\t\t\t\tif (typeof (value) === \"string\" && value.indexOf(\"$\") > -1) {\n\t\t\t\t\tconfigArray[i] = resolveString(value);\n\t\t\t\t} else if (value instanceof Array) {\n\t\t\t\t\tresolveArray(value, pass, recursionLevel + 1); // array reference passed so don't need return value\n\t\t\t\t} else if (typeof (value) === \"object\") {\n\t\t\t\t\tresolveObject(value, pass, recursionLevel + 1); // object reference passed so don't need return value\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// process an object of config properties looking for variables to resolve (a recursive routine)\n\t\tfunction resolveObject(configObject, pass, recursionLevel) {\n\t\t\tLogger.system.verbose(\"resolveObject\", \"pass\", pass, \"recursionLevel\", recursionLevel, \"configObject:\", configObject);\n\t\t\tObject.keys(configObject).forEach(function (key) {\n\t\t\t\tvar value = configObject[key];\n\t\t\t\tif (typeof (value) === \"string\" && value.indexOf(\"$\") > -1) {\n\t\t\t\t\tconfigObject[key] = resolveString(value);\n\t\t\t\t} else if (value instanceof Array) {\n\t\t\t\t\tresolveArray(value, pass, recursionLevel + 1); // array reference passed so don't need return value\n\t\t\t\t} else if (typeof (value) === \"object\") {\n\t\t\t\t\tresolveObject(value, pass, recursionLevel + 1); // object reference passed so don't need return value\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// since variables may be nested, keep resolving till no more left\n\t\twhile (needsAnotherPass) {\n\t\t\tneedsAnotherPass = false; // don't need another pass afterwards unless a variable is resolved somewhere in finsembleConfig\n\t\t\tresolveObject(startingConfigObject, ++pass, 1);\n\t\t}\n\t},\n\n\t// This does mimimal processing of the manifest, just enough to support getting the router up, which is only expanding variables (e.g. moduleRoot) in the raw manifest\n\tgetExpandedRawManifest(callback) {\n\t\tLogger.system.debug(\"getExpandedRawManifest starting\");\n\n\t\tfunction getRawManifest(callback, application, level) {\n\t\t\tLogger.system.debug(\"getRawManifest\", application, level);\n\n\n\t\t\tapplication.getManifest(function (manifest) { // get raw openfin manifest\n\t\t\t\tLogger.system.debug(\"getExpandedRawManifest manifest\", manifest);\n\n\t\t\t\tConfigUtil.resolveConfigVariables(manifest.finsemble, manifest.finsemble); // resolve variables first time so can fild config config location\n\t\t\t\tLogger.system.debug(\"getExpandedRawManifest Complete\", manifest);\n\t\t\t\tcallback(manifest);\n\t\t\t}, function (err) {\n\t\t\t\tLogger.system.debug(\"getExpandedRawManifest err\", err);\n\t\t\t\t// no manifest so try parent\n\t\t\t\tapplication.getParentUuid(function (parentUuid) {\n\t\t\t\t\tvar parentApplication = fin.desktop.Application.wrap(parentUuid);\n\t\t\t\t\tLogger.system.debug(\"uuid\", parentUuid, \"parentApplication\", parentApplication);\n\t\t\t\t\tif (level < 10) {\n\t\t\t\t\t\tgetRawManifest(callback, parentApplication, ++level);\n\t\t\t\t\t} else { // still could find so must be a problem (i.e. avoid infinite loop)\n\t\t\t\t\t\tcallback(\"could not find manifest in parent applications\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tfin.desktop.main(function () { // make sure openfin is ready\n\t\t\tvar application = fin.desktop.Application.getCurrent();\n\t\t\tgetRawManifest(callback, application, 1);\n\t\t});\n\t},\n\n\t// This does a \"first stage\" processing of the manifest, providing enought config to start finsemble.\n\t// Pull in the initial manifest, which includes gettig the \"hiddlen\" core config file along with its import definitions, and expand all variables.\n\t// However, the full config processing, incluing actually doing the imports, is only done in the Config Service.\n\tgetInitialManifest(callback) {\n\t\tvar CORE_CONFIG; // will hold location of core config file\n\n\t\t// async read of JSON config file\n\t\tfunction getCoreConfig(coreConfigFile, importCallback) {\n\t\t\tLogger.system.debug(\"fetching \" + coreConfigFile);\n\t\t\tfetch(coreConfigFile, {\n\t\t\t\tcredentials: \"include\"\n\t\t\t}).then(function (response) {\n\t\t\t\treturn response.json();\n\t\t\t}).catch(function (err) {\n\t\t\t\timportCallback(\"failure importing \" + err, null);\n\t\t\t}).then(function (importObject) {\n\t\t\t\timportCallback(null, importObject);\n\t\t\t});\n\t\t}\n\n\t\tfin.desktop.main(function () { // make sure openfin is ready\n\t\t\tvar application = fin.desktop.Application.getCurrent();\n\t\t\tapplication.getManifest(function (manifest) { // get raw openfin manifest\n\t\t\t\tConfigUtil.resolveConfigVariables(manifest.finsemble, manifest.finsemble); // resolve variables first time so can fild config config location\n\t\t\t\tvar CORE_CONFIG = manifest.finsemble.moduleRoot + \"/configs/core/config.json\"; // <<<--- here is the \"hidden\" core config file\n\t\t\t\tgetCoreConfig(CORE_CONFIG, function (error, newFinsembleConfigObject) { // fetch the core config file\n\t\t\t\t\tif (!error) {\n\t\t\t\t\t\tObject.keys(newFinsembleConfigObject).forEach(function (key) {\n\t\t\t\t\t\t\tif (key === \"importConfig\") {\n\t\t\t\t\t\t\t\t// add any importConfig items from the core to the existing importConifg\n\t\t\t\t\t\t\t\tmanifest.finsemble.importConfig = manifest.finsemble.importConfig || [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < newFinsembleConfigObject.importConfig.length; i++) {\n\t\t\t\t\t\t\t\t\tmanifest.finsemble.importConfig.unshift(newFinsembleConfigObject.importConfig[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (key === \"importThirdPartyConfig\") {\n\t\t\t\t\t\t\t\t// add any importThirdPartyConfig items from the core to the existing importConifg\n\t\t\t\t\t\t\t\tmanifest.finsemble.importThirdPartyConfig = manifest.finsemble.importThirdPartyConfig || [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < newFinsembleConfigObject.importThirdPartyConfig.length; i++) {\n\t\t\t\t\t\t\t\t\tmanifest.finsemble.importThirdPartyConfig.unshift(newFinsembleConfigObject.importThirdPartyConfig[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmanifest.finsemble[key] = newFinsembleConfigObject[key];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tConfigUtil.resolveConfigVariables(manifest.finsemble, manifest.finsemble); // resolve variables with finsemble config\n\t\t\t\t\t\tLogger.system.debug(\"Initial Manifest after variables Resolved\", manifest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.system.error(\"failed importing into finsemble config\", currentImportURL, error);\n\t\t\t\t\t}\n\t\t\t\t\tcallback(manifest);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n};\n\nmodule.exports = ConfigUtil;\n\n\n// WEBPACK FOOTER //\n// src/common/configUtil.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACdA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlHA;AACA;AAoHA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7RA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACr5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClKA;;;;AAIA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA9tBA;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpEA;;;;AAIA;AACA;AACA;;;;;;AAMA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3JA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;ACjEA;;;;;AAKA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAFA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AADA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AADA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAGA;AADA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;;;;;;;ACpGA;;;;;AAKA;;;;;;AAMA;;;;;AAKA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;;;;;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AA8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACvrCA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1JA;AACA;AA4JA;;;;A","sourceRoot":""}