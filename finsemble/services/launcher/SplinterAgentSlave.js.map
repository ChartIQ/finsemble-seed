{"version":3,"file":"services/launcher/SplinterAgentSlave.js","sources":["webpack:///webpack/bootstrap eb288a3e36488b555e4d?82a0*********","webpack:///./~/node-libs-browser/~/process/browser.js?494c*********","webpack:///./src/clients/logger.js?e4f8*********","webpack:///./src/common/routerTransport.js?2fc6*********","webpack:///./src/clients/routerClientConstructor.js?fe47*********","webpack:///./src/common/util.js?b343*********","webpack:///./src/common/validate.js?611e*********","webpack:///./src/clients/routerClientInstance.js?3384*********","webpack:///./src/services/launcher/SplinterAgentSlave.js","webpack:///./src/common/systemSettings.js?40b6*********","webpack:///./src/common/configUtil.js?1ec6*********"],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"http://localhost:3375/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 74);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap eb288a3e36488b555e4d","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/node-libs-browser/~/process/browser.js\n// module id = 0\n// module chunks = 0 1 2 3 4 5 6 7 8 9 10 11","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\"use strict\";\n\nconst LOCAL_ONLY_DEFAULT = false; // if true all logging will default to local console; will be overwritten by LoggerService's registration response\n\n// capture everything at startup; will be filtered later as needed when LoggerService's registration response provides settings; overhead here is not too high\nvar DEFAULT_LOG_SETTING = { Error: true, Warn: true, Info: true, Log: true, Debug: true, Verbose: true, LocalOnly: LOCAL_ONLY_DEFAULT }; // if true captured for logger\nvar CONSOLE_DEFAULT_LOG_SETTING = { Error: true, Warn: true, Info: true, Log: true, Debug: true }; // if true then goes to console and captured for logger\n\nconst MAX_QUEUE_SIZE = 10 * 1000; // maximum logger queue size; plenty of space although shouldn't need much since continuely sending to logger if working correctly;\n\nvar Validate = require(\"../common/validate\"); // Finsemble args validator\nvar RouterClient; // wait till start to fill in\n\n/**\n * @introduction\n * <h2>Config Client</h2>\n *\n * This client provides run-time access to Finsemble's configuration. See [Understanding Finsemble's Configuration]{@tutorial understandingConfiguration} for a configuration overview.\n *\n * @hideConstructor true\n * @constructor\n */\nvar Logger = function () {\n\tvar self = this;\n\tvar isRegistering = false; // if registering start\n\tvar isRegistered = false; // if registering complete\n\tvar isActiveTransmitTimer = false;\n\tvar loggerConsole = self;\n\tvar updatedLogState;\n\tvar isStarted = false;\n\tvar isReady = false;\n\tvar calibratedTimeStampOffset = 0;\n\tvar newCalibratedTimeStampOffset;\n\n\tvar loggerQueue = [];\n\tvar warningIssued = false; // used to limit warning messages\n\n\tvar loggerClientName = window.name;\n\tif (window.top !== window) { // amend name if iFrame\n\t\tloggerClientName += \".Frame\";\n\t}\n\tvar clientChannel = \"finsemble.logger.client.\" + loggerClientName;\n\n\tconst CATEGORIES = [\"console\", \"dev\", \"system\", \"perf\"];\n\n\tvar initialLogState = {}; // will be updated on registration with central console, but capture everything until then\n\tinitialLogState.console = CONSOLE_DEFAULT_LOG_SETTING;\n\tinitialLogState.dev = DEFAULT_LOG_SETTING;\n\tinitialLogState.system = DEFAULT_LOG_SETTING;\n\tinitialLogState.perf = DEFAULT_LOG_SETTING;\n\n\tvar currentLogState = initialLogState;\n\n\tfunction LoggerMessage(category, type, data) {\n\t\tthis.category = category;\n\t\tthis.logClientName = loggerClientName;\n\t\tthis.logType = type;\n\t\tthis.logData = data;\n\t\tthis.logTimestamp = window.performance.timing.navigationStart + window.performance.now() + calibratedTimeStampOffset;\n\t}\n\n\tfunction addToQueue(message) {\n\t\tif (loggerQueue.length < MAX_QUEUE_SIZE) {\n\t\t\tloggerQueue.push(message);\n\t\t} else {\n\t\t\tif (!warningIssued) {\n\t\t\t\tconsole.warn(\"Logging Queue Overflowed!\", loggerQueue);\n\t\t\t\twarningIssued = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// if log state changes then update queue based on that data (e.g. if no longer logging debug messages, then remove them from the queue)\n\tfunction updateQueueBasedOnState(calibrateTimeFlag) {\n\t\tloggerConsole.system.debug(\"Logger updateQueueBasedOnState\", calibrateTimeFlag, calibratedTimeStampOffset, \"QUEUE LENGTH\", loggerQueue.length, currentLogState);\n\t\tvar newQueue = [];\n\t\tfor (var i = 0, length = loggerQueue.length; i < length; i++) {\n\t\t\tif (currentLogState[loggerQueue[i].category][loggerQueue[i].logType] && !currentLogState[loggerQueue[i].category].LocalOnly) {\n\t\t\t\tif (calibrateTimeFlag) {\n\t\t\t\t\tloggerQueue[i].logTimestamp += calibratedTimeStampOffset; // if flag set then timestamp hasn't been adjusted yet by calibrated offset time\n\t\t\t\t}\n\t\t\t\tnewQueue.push(loggerQueue[i]);\n\t\t\t} else { // only now know LocalOnly for messages, so print those queued out otherwise they will be lost\n\t\t\t\tif (currentLogState[loggerQueue[i].category][loggerQueue[i].logType] && currentLogState[loggerQueue[i].category].LocalOnly) {\n\t\t\t\t\tlet msg = loggerQueue[i];\n\t\t\t\t\tconsole.log(msg.category, msg.logType, msg.logTimestamp - window.performance.timing.navigationStart, msg.logData, \"(Previously queued!)\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tloggerQueue = newQueue;\n\t}\n\n\tthis.setClientName = function (name) {\n\t\tloggerClientName = name;\n\t};\n\n\tthis.getClientName = function (name) {\n\t\treturn loggerClientName;\n\t};\n\n\tthis.clearMessageList = function () {\n\t\tloggerQueue = [];\n\t};\n\n\tfunction setLogState(state, calibrateTimeFlag) {\n\t\tcurrentLogState = state;\n\t\tupdateQueueBasedOnState(calibrateTimeFlag);\n\t}\n\n\t// returns a stack-trace substring\n\tfunction oldtraceString() {\n\t\tvar tString = new Error().stack;\n\t\treturn tString;\n\t}\n\n\tfunction traceString() {\n\t\tfunction getPosition(string, subString, index) {\n\t\t\treturn string.split(subString, index).join(subString).length;\n\t\t}\n\n\t\tfunction getErrorObject() {\n\t\t\ttry { throw Error(\"\"); } catch (err) { return err; }\n\t\t}\n\t\tvar stack = getErrorObject().stack;\n\t\tvar position = getPosition(stack, \"\\n\", 4);\n\t\tvar tString = stack.substring(position); // strip off irrelevant part of stack\n\t\tvar final = \"Log Stack: \\n\" + tString.substr(1); // insert description\n\t\treturn final;\n\t}\n\n\t// save original console functions since going to wrap/redefine each\n\tvar orignalConsoleError = console.error;\n\tvar orignalConsoleWarn = console.warn;\n\tvar orignalConsoleInfo = console.info;\n\tvar orignalConsoleLog = console.log;\n\tvar orignalConsoleDebug = console.debug;\n\n\t// expose original console in case client still wants to directly access\n\tconsole.original = {};\n\tconsole.original.error = console.error;\n\tconsole.original.warn = console.warn;\n\tconsole.original.info = console.info;\n\tconsole.original.log = console.log;\n\tconsole.original.debug = console.debug;\n\n\t// option to restore console (i.e. use Logger without overriding console) -- not yet tested\n\tthis.restoreConsole = function () {\n\t\tconsole.error = orignalConsoleError;\n\t\tconsole.warn = orignalConsoleWarn;\n\t\tconsole.info = orignalConsoleInfo;\n\t\tconsole.log = orignalConsoleLog;\n\t\tconsole.debug = orignalConsoleDebug;\n\t};\n\n\tfunction formatAndQueueMessage(category, type, args) {\n\t\tvar message;\n\t\ttry {\n\t\t\tmessage = new LoggerMessage(category, type, JSON.stringify(args));\n\t\t} catch (err) {\n\t\t\targs.splice(0, args.length); // clear but don't redefine since must return updated value\n\t\t\targs.push(traceString());\n\t\t\tmessage = new LoggerMessage(category, type, \"*** Logging Error: \" + JSON.stringify(args));\n\t\t}\n\n\t\taddToQueue(message);\n\n\t\tif (isRegistered) {\n\t\t\tif (!isActiveTransmitTimer) { // since log message added to queue, only set timer to transmit log if not already set\n\t\t\t\tif (loggerClientName === \"routerService\") {\n\t\t\t\t\tsetTimeout(transmitAndClearQueue, 100); // HERE is the interval for transmitting queued messages to the logger service\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(transmitAndClearQueue, 250); // HERE is the interval for transmitting queued messages to the logger service\n\t\t\t\t}\n\t\t\t\tisActiveTransmitTimer = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction transmitAndClearQueue() {\n\t\tRouterClient.transmit(\"logger.service.logMessages\", loggerQueue);\n\t\tloggerConsole.clearMessageList();\n\t\tisActiveTransmitTimer = false; // flag for supporting log transmit only when there is something in the log queue\n\t}\n\n\tfunction outputToConsole(consoleType, args) {\n\t\ttry {\n\t\t\tconsoleType.apply(console, args);\n\t\t} catch (err) {\n\t\t\targs = [];\n\t\t\targs.push(traceString());\n\t\t\tmessage = new LoggerMessage(category, type, \"*** Console Logging Error: \" + JSON.stringify(args));\n\t\t}\n\t}\n\n\t// wrap main console functions\n\tconsole.error = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleError, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Error && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Error\", args);\n\t\t}\n\t};\n\n\tconsole.warn = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleWarn, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Warn && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Warn\", args);\n\t\t}\n\t};\n\n\tconsole.info = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleInfo, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Info && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Info\", args);\n\t\t}\n\t};\n\n\tconsole.log = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleLog, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Log && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Log\", args);\n\t\t}\n\t};\n\n\tconsole.debug = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\toutputToConsole(orignalConsoleDebug, args); // output to console before adding trace\n\t\targs.push(traceString());\n\t\tif (currentLogState.console.Debug && !currentLogState.console.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"console\", \"Debug\", args);\n\t\t}\n\t};\n\n\t// dev mode functions\n\tthis.error = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\n\t\tif (currentLogState.dev.Error && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Error\", args);\n\t\t}\n\n\t\targs.unshift(\"dev error (\" + window.performance.now() + \"):\");\n\t\toutputToConsole(orignalConsoleError, args);\n\t};\n\n\tthis.warn = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Warn && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Warn\", args);\n\t\t}\n\t\tif (currentLogState.dev.Warn && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev warn (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleWarn, args);\n\t\t}\n\t};\n\n\tthis.info = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Info && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Info\", args);\n\t\t}\n\t\tif (currentLogState.dev.Info && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev info (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleInfo, args);\n\t\t}\n\t};\n\n\tthis.log = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Log && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Log\", args);\n\t\t}\n\t\tif (currentLogState.dev.Log && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev log (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleLog, args);\n\t\t}\n\t};\n\n\tthis.debug = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Debug && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Debug\", args);\n\t\t}\n\t\tif (currentLogState.dev.Debug && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev debug (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\tthis.verbose = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.dev.Verbose && !currentLogState.dev.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"dev\", \"Verbose\", args);\n\t\t}\n\t\tif (currentLogState.dev.Verbose && currentLogState.dev.LocalOnly) {\n\t\t\targs.unshift(\"dev verbose (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\t// system mode functions\n\tthis.system = {};\n\tthis.system.error = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\n\t\tif (currentLogState.system.Error && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Error\", args);\n\t\t}\n\n\t\targs.unshift(\"system error (\" + window.performance.now() + \"):\");\n\t\toutputToConsole(orignalConsoleError, args);\n\t};\n\n\tthis.system.warn = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Warn && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Warn\", args);\n\t\t}\n\t\tif (currentLogState.system.Warn && currentLogState.system.LocalOnly) {\n\t\t\targs.unshift(\"system warn (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleWarn, args);\n\t\t}\n\t};\n\n\tthis.system.info = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Info && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Info\", args);\n\t\t}\n\t\tif (currentLogState.system.Info && currentLogState.system.LocalOnly) {\n\t\t\targs.unshift(\"system info (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleInfo, args);\n\t\t}\n\t};\n\n\tthis.system.log = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Log && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Log\", args);\n\t\t}\n\t\tif (currentLogState.system.Log && currentLogState.system.LocalOnly) {\n\t\t\targs.unshift(\"system log (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleLog, args);\n\t\t}\n\t};\n\n\tthis.system.debug = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Debug && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Debug\", args);\n\t\t}\n\t\tif (currentLogState.system.Debug && currentLogState.system.LocalOnly) {\n\t\t\targs.unshift(\"system debug (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\tthis.system.verbose = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.system.Verbose && !currentLogState.system.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"system\", \"Verbose\", args);\n\t\t}\n\t\tif (currentLogState.system.Verbose && currentLogState.system.LocalOnly) {\n\t\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\t\targs.unshift(\"system log (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\t// performance mode functions\n\tthis.perf = {};\n\tthis.perf.error = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\n\t\tif (currentLogState.perf.Error && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Error\", args);\n\t\t}\n\n\t\targs.unshift(\"perf error (\" + window.performance.now() + \"):\");\n\t\toutputToConsole(orignalConsoleError, args);\n\t};\n\n\tthis.perf.warn = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Warn && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Warn\", args);\n\t\t}\n\t\tif (currentLogState.perf.Warn && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf warn (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleWarn, args);\n\t\t}\n\t};\n\n\tthis.perf.info = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Info && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Info\", args);\n\t\t}\n\t\tif (currentLogState.perf.Info && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf info (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleInfo, args);\n\t\t}\n\t};\n\n\tthis.perf.log = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Log && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Log\", args);\n\t\t}\n\t\tif (currentLogState.perf.Log && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf log (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleLog, args);\n\t\t}\n\t};\n\n\tthis.perf.debug = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Debug && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Debug\", args);\n\t\t}\n\t\tif (currentLogState.perf.Debug && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf debug (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\tthis.perf.verbose = function () {\n\t\tvar args = Array.prototype.slice.call(arguments); // make a real array so can manipulate\n\t\targs.push(traceString());\n\t\tif (currentLogState.perf.Verbose && !currentLogState.perf.LocalOnly) {\n\t\t\tformatAndQueueMessage(\"perf\", \"Verbose\", args);\n\t\t}\n\t\tif (currentLogState.perf.Verbose && currentLogState.perf.LocalOnly) {\n\t\t\targs.unshift(\"perf verbose (\" + window.performance.now() + \"):\");\n\t\t\toutputToConsole(orignalConsoleDebug, args);\n\t\t}\n\t};\n\n\tfunction registerClient() {\n\t\tloggerConsole.system.debug(\"logger.service.registering\", loggerClientName);\n\t\tif (!LOCAL_ONLY_DEFAULT) {\n\t\t\tRouterClient.query(\"logger.service.register\", { clientName: loggerClientName, clientChannel }, function (error, queryMessage) {\n\t\t\t\tif (error) { // for some very early clients the logger may not be ready yet, so retry after a small wait\n\t\t\t\t\tsetTimeout(registerClient, 750);\n\t\t\t\t} else {\n\t\t\t\t\tisRegistered = true;\n\t\t\t\t\tloggerConsole.system.debug(\"logger.service.register response\", queryMessage.data);\n\t\t\t\t\tupdatedLogState = queryMessage.data;\n\t\t\t\t\tif (loggerClientName !== \"routerService\") {\n\t\t\t\t\t\tcalibratedTimeStampOffset = newCalibratedTimeStampOffset; // from now the real offset time will be used for all timestamps\n\t\t\t\t\t\tsetLogState(updatedLogState, true); // true indicates must adjust already queued timestamps by the new offset time\n\t\t\t\t\t} else { // router services doesn't need to calibrate time since it is the reference time\n\t\t\t\t\t\tsetLogState(updatedLogState, false);\n\t\t\t\t\t}\n\t\t\t\t\tformatAndQueueMessage(\"system\", \"Info\", [\"Logger Registered\"]);\n\t\t\t\t\ttransmitAndClearQueue();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tRouterClient.addListener(clientChannel, function (error, message) {\n\t\t\tloggerConsole.system.debug(\"logger.client.setLogState\", message.data);\n\t\t\tupdatedLogState = message.data;\n\t\t\tsetLogState(updatedLogState, false);\n\t\t});\n\t}\n\n\tfunction unregisterClient() {\n\t\tloggerConsole.system.debug(\"logger.service.unregister\", loggerClientName);\n\t\ttransmitAndClearQueue(); // send any message currently in the log queue\n\t\tRouterClient.query(\"logger.service.unregister\", { clientName: loggerClientName }, function () { });\n\t}\n\n\tfunction registerOnceWhenStarted() {\n\t\tif (!isRegistering) {\n\t\t\tregisterClient();\n\t\t\twindow.addEventListener(\"beforeunload\", unregisterClient);\n\t\t\tisRegistering = true;\n\t\t}\n\t}\n\n\tthis.isLogMessage = function (channel) {\n\t\treturn (channel === \"logger.service.logMessages\");\n\t};\n\n\tthis.start = function () {\n\t\tRouterClient = require(\"./routerClientInstance\");\n\t\tRouterClient.onReady(function () {\n\t\t\tloggerConsole.system.debug(\"Logger onReady\", loggerClientName);\n\t\t\t// timer calibration must be done so the messages will be correctly sorted in the central logger;\n\t\t\t// this is necessary because there is timer driff between windows --- this appears to be a Chromium\n\t\t\t// bug we have to work around it.  The timeOffset value adjusts the time using the routerService's\n\t\t\t// time as a central reference point.\n\t\t\tRouterClient.calibrateTimeWithRouterService(function (timeOffset) {\n\t\t\t\tnewCalibratedTimeStampOffset = timeOffset;\n\t\t\t\tregisterOnceWhenStarted();\n\t\t\t});\n\t\t});\n\t};\n};\n\nvar logger = new Logger();\n\nmodule.exports = logger;\n\n\n\n// WEBPACK FOOTER //\n// ./src/clients/logger.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n// This routerTransport module is shared between router clients and the router service.  It supports\n// the addition of new transports without any change to the router code. Each transport is\n// point-to-point between a router client and the router service (i.e. hub and spoke).  Each router\n// client can use a different transport (i.e. the router service connects to them all).\n\n\"use strict\";\nvar Utils = require(\"../common/util\");\nvar console = new Utils.Console(\"RouterTransport\"); // Finsemble console\n\n/**\n * @introduction\n * <h2>Router Transport</h2>\n * **Service-Level Module**.  Manages and contains the point-to-point transports (i.e. Layer 2) supported by Finsemble.\n * Each transport communicates betweew a Finsemble services or component (on one end) and the Finsemble router (on the other end).\n *\n * The OpenFinBus transport is used for cross-domain components (where SharedWorker fails).\n *\n * Requirements for adding a new transport:\n * 1) create new transport object with same interface provided by SharedWorkerTransport and OpenFinTransport in this file.\n * 2) call RouterTransport.addTransport() to make the transport available (see the bottom of this file)\n *\n * Integration into routerService.js is automatic.\n *\n * @namespace RouterTransport\n */\nvar RouterTransport = {\n\n\tactiveTransports: {},\n\n\t/**\n\t * Adds a new type of router transport to pass message between RouterClient and RouterService.\n\t *\n\t * @param {string} transportName identifies the new transport\n\t * @param {object} transportConstructor returns an instance of the new transport\n\t */\n\taddTransport: function (transportName, transportConstructor) {\n\t\tthis.activeTransports[transportName] = transportConstructor;\n\t\twindow.console.info(\"RouterTransport added: \" + transportName);\n\t},\n\n\t/**\n\t * Gets array of active transports\n\t *\n\t * @returns array transport names/identifier\n\t */\n\tgetActiveTransports: function () {\n\t\tvar transportNames = [];\n\t\tfor (var transportIdentifier in this.activeTransports) {\n\t\t\ttransportNames.push(transportIdentifier);\n\t\t}\n\t\treturn transportNames;\n\t},\n\n\t/**\n\t * Get default transport for event router -- this is the most reliable transport across all contexts\n\t *\n \t * @param {object} params parameters for transport\n\t * @param {any} incomingMessageHandler\n\t * @param {any} source\n\t * @param {any} destination\n\t * @returns the transport object\n\t */\n\tgetDefaultTransport: function (params, incomingMessageHandler, source, destination) {\n\t\treturn RouterTransport.getTransport(params, \"OpenFinBus\", incomingMessageHandler, source, destination);\n\t},\n\n\t/**\n\t * Get best client transport based on the run-time context. Will only return cross-domain transport if current context is inter-domain.\n\t *\n \t * @param {object} params parameters for transport\n\t * @param {any} incomingMessageHandler\n\t * @param {any} source\n\t * @param {any} destination\n\t * @returns the transport object\n\t */\n\tgetRecommendedTransport: function (params, incomingMessageHandler, source, destination) {\n\t\tvar newTransport; // return variable\n\n\t\t// Will tell you if the window is in an iframe or not (for future)\n\t\tfunction isInIframe() {\n\t\t\ttry {\n\t\t\t\treturn window.self !== window.top;\n\t\t\t} catch (e) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\t// returns true if this window's location is in another domain\n\t\tfunction crossDomain() {\n\t\t\tvar parser = document.createElement('a');\n\t\t\tparser.href = params.routerDomainRoot;\n\n\t\t\tvar isSameHost = (window.location.hostname === parser.hostname);\n\n\t\t\tvar isSameProtocol = (window.location.protocol === parser.protocol);\n\n\t\t\tvar wport = (window.location.port === undefined) ? window.location.port : 80;\n\t\t\tvar pport = (parser.port === undefined) ? parser.port : 80;\n\t\t\tvar isSamePort = (wport === pport);\n\n\t\t\tvar isCrossDomain = params.forceRouterToOFB || !(isSameHost && isSamePort && isSameProtocol);\n\t\t\tconsole.debug(\"Transport crossDomain=\" + isCrossDomain + \" (\" + params.forceRouterToOFB + \":\" + isSameHost + \":\" + isSameProtocol + \":\" + isSamePort + \")\");\n\t\t\treturn isCrossDomain;\n\t\t}\n\n\t\t// returns name of the best transport for communicating with router service\n\t\tfunction recommendedTransportName() {\n\t\t\tvar recommendedName = \"SharedWorker\"; // default -- fast but doesn't work cross-domain\n\t\t\tif (crossDomain()) {\n\t\t\t\trecommendedName = \"OpenFinBus\"; // required for cross-domain event messaging between windows\n\t\t\t}\n\t\t\treturn recommendedName;\n\t\t}\n\n\t\tvar transportName = recommendedTransportName();\n\t\treturn RouterTransport.getTransport(params, transportName, incomingMessageHandler, source, destination);\n\t},\n\n\t/**\n\t * Get a specific transport by name. The transport must be in list of the active transports (i.e. previously added).\n\t *\n \t * @param {object} params parameters for transport\n\t * @param {any} transportName\n\t * @param {any} incomingMessageHandler\n\t * @param {any} source\n\t * @param {any} destination\n\t * @returns the transport object\n\t */\n\tgetTransport: function (params, transportName, incomingMessageHandler, source, destination) {\n\t\tvar self = this;\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tvar transportConstructor = self.activeTransports[transportName];\n\t\t\tif (transportConstructor) {\n\t\t\t\tvar newTransport = new transportConstructor(params, transportName, incomingMessageHandler, source, destination);\n\t\t\t\tresolve(newTransport);\n\t\t\t} else {\n\t\t\t\treject(\"unknown transport name: \" + transportName);\n\t\t\t}\n\t\t});\n\t}\n};\n\n//////////////////////////////////////////////////////////////\n// Below all transports are defined then added to active list\n//////////////////////////////////////////////////////////////\n\nvar RouterTransportImplementation = {}; // a convenience namespace for router-transport implementations\n\n/*\n * Implements the SharedWorker Transport.\n *\n * Required Functions (used by transport clients):\n * \t\tsend(eventMessage) -- transports the event\n * \t\tidentifier() -- returns transport name/identifier\n *\n * @param {object} params parameters for SharedWorker transport\n * @param {object} name the name the transport will be reference by\n * @param {any} parentMessageHandlerParm callback for incoming event\n * @param {any} source for the transport (e.g. \"RouterClient\" or \"RouterService\")\n */\nRouterTransportImplementation.SharedWorkerTransport = function (params, name, parentMessageHandlerParm, source) {\n\tvar parentMessageHandler;\n\tvar routerThread;\n\tvar transportName;\n\tvar console = new Utils.Console(\"SharedWorkerTransport.\" + source); // Finsemble console\n\n\n\t// receives incoming shared-worker messages then passes on to parent with correct \"wrapper\"\n\tfunction sharedWorkerMessageHandler(swMessage) {\n\t\tvar port = swMessage.data[0];\n\t\tvar eventMessage = swMessage.data[1];\n\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"port\": port };\n\t\tconsole.debug2(\"Incoming Transport\", incomingTransportInfo, \"Message\", eventMessage);\n\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\n\t}\n\n\t//required function for parent (i.e. routeClient or routeService)\n\tthis.send = function (transport, eventMessage) {\n\t\t// handle optional transport parm\n\t\tif (arguments.length === 1) {  // clients use just one parm -- eventMessage\n\t\t\teventMessage = arguments[0];\n\t\t\ttransport = null;\n\t\t\tconsole.debug2(\"Outgoing Transport\", transportName, \"Message\", eventMessage);\n\t\t} else { // router services uses both parameters\n\t\t\ttransport = arguments[0];\n\t\t\teventMessage = arguments[1];\n\t\t\tconsole.debug2(\"Outgoing Transport\", transport, \"Message\", eventMessage);\n\t\t}\n\t\ttry {\n\t\t\trouterThread.port.postMessage([transport, eventMessage]);\n\t\t}\n\t\tcatch (e) {\n\t\t\tconsole.error(\"routerThread post message failed: \" + JSON.stringify(e), \"Probable cause is sending illegal data type (e.g. function).\");\n\t\t}\n\t};\n\n\t//required function for parent (i.e. routeClient or routeService)\n\tthis.identifier = function () {\n\t\treturn transportName;\n\t};\n\n\tconsole.debug(\"SharedWorker \" + params.routerSharedWorker + \" Initializing: \" + source);\n\ttransportName = name;\n\tparentMessageHandler = parentMessageHandlerParm;\n\trouterThread = new SharedWorker(params.routerSharedWorker, { name: \"Finsemble\", credentials: \"included\" });\n\trouterThread.port.onmessage = sharedWorkerMessageHandler;\n\trouterThread.onerror = function (e) {\n\t\tconsole.error(\"RouteClient SharedWorker Error\" + JSON.stringify(e));\n\t};\n\trouterThread.port.start();\n\n\tif (source === \"RouterService\") {  // send first message though shared worker to identify router service\n\t\trouterThread.port.postMessage({ data: \"connect\", source: \"RouterService\" });\n\t}\n};\n\n/*\n * Implements the OpenFin Bus Transport.\n *\n * Required Functions (used by transport clients):\n * \t\tsend(event) -- transports the event\n * \t\tidentifier() -- returns transport name/identifier\n *\n * @param {object} params unused in OpenFin transport\n * @param {object} name the name the transport will be reference by\n * @param {any} parentMessageHandlerParm callback for incoming event\n * @param {any} source for the transport (e.g. \"RouterClient\" or \"RouterService\")\n * @param {any} destination for the transport (e.g. \"RouterService\" or \"RouterClient\" )\n */\nRouterTransportImplementation.OpenFinTransport = function (params, name, parentMessageHandlerParm, source, destination) {\n\tvar parentMessageHandler;\n\tvar transportName;\n\tvar console = new Utils.Console(\"OpenFinTransport.\" + source); // Finsemble console\n\tvar uuid = fin.desktop.Application.getCurrent().uuid;\n\n\t// receives incoming OpenFin bus messages then passes on to parent with correct \"wrapper\"\n\tfunction openFinMessageHandler(eventMessage, senderUuid, name) {\n\t\tvar incomingTransportInfo = { \"transportID\": transportName, \"senderUuid\": senderUuid, \"name\": eventMessage.header.origin };\n\t\tconsole.debug2(\"Incoming Transport\", incomingTransportInfo, \"Message\", eventMessage);\n\t\tparentMessageHandler(incomingTransportInfo, eventMessage);\n\t}\n\n\tfunction subscribeFailure(reason) {\n\t\tconsole.error(\"OpenFinBus Subscribe Failure: \" + reason);\n\t}\n\n\t//required function for the parent (i.e. routeClient or routeService)\n\tthis.send = function (transport, eventMessage) {\n\t\tvar destTopic;\n\n\t\t// handle optional transport parm\n\t\tif (arguments.length === 1) { // client use just one parameter - eventMessage\n\t\t\tdestTopic = destination;\n\t\t\teventMessage = arguments[0];\n\t\t} else { // router service uses both parameters\n\t\t\tdestTopic = transport.name;\n\t\t\teventMessage = arguments[1];\n\t\t}\n\n\t\tconsole.debug2(\"Outgoing Transport\", uuid, destTopic, \"Message\", eventMessage);\n\t\tfin.desktop.InterApplicationBus.publish(destTopic, eventMessage,\n\t\t\tfunction () { }, function (err) { });\n\t};\n\n\t//required function for the parent (i.e. routeClient or routeService)\n\tthis.identifier = function () {\n\t\treturn transportName;\n\t};\n\n\ttransportName = name;\n\tparentMessageHandler = parentMessageHandlerParm;\n\twindow.console.debug(\"OpenFinBus Initializing: \" + source);\n\tfin.desktop.InterApplicationBus.subscribe('*', source, openFinMessageHandler, null, subscribeFailure);\n};\n\n// add the transports to the available/active list\nRouterTransport.addTransport(\"SharedWorker\", RouterTransportImplementation.SharedWorkerTransport);\n\nRouterTransport.addTransport(\"OpenFinBus\", RouterTransportImplementation.OpenFinTransport);\n\nmodule.exports = RouterTransport;\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/routerTransport.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n\"use strict\";\nvar RouterTransport = require(\"../common/routerTransport\");\nvar Utils = require(\"../common/util\");\nvar ConfigUtil = require(\"../common/configUtil\");\nvar Validate = require(\"../common/validate\"); // Finsemble args validator\nvar queue = []; // should never be used, but message sent before router ready will be queue\n\nvar Logger = require(\"./logger\");\nLogger.system.log(\"Starting RouterClient\");\n\n\n/**\n * @introduction\n *\n * <h2>Event Router Client</h2>\n *\n * This module contains the RouterClient for sending and receiving events between Finsemble components and services.  See <a href=tutorial-usingTheEventRouter.html>Event Router Tutorial</a> for an overview of the router's functionality.\n *\n * *Event router callbacks for incoming messages are always in the form `callback(error, event)`.  If `error` is null, then the incoming data is always in `event.data`. If error is set, it contains a diagnotic object and message.  On error, the `event` parameter is not undefined.*\n *\n *\n * @constructor\n * @hideConstructor true\n * @publishedName RouterClient\n * @param {string} thisClientName router client name for human readable messages\n * @param {string=} transportName router transport name, currently either \"SharedWorker\" or \"OpenFinBus\" (usually this is autoconfigured internally but can be selected for testing or special configurations)\n */\nvar RouterClientConstructor = function (params) {\n\tValidate.args(params, \"object\") && Validate.args2(\"params.clientName\", params.clientName, \"string\", \"params.transportName\", params.transportName, \"string=\");\n\n\t///////////////////////////\n\t// Private Data\n\t///////////////////////////\n\tvar thisClientName = params.clientName;\n\tvar transportName = params.transportName;\n\tvar handshakeHandler;\n\tvar timeCalibrationHandler;\n\tvar mapListeners = {};\n\tvar mapResponders = {};\n\tvar mapPubSubResponders = {};\n\tvar mapPubSubResponderState = {};\n\tvar mapPubSubResponderRegEx = {};\n\tvar pubsubListOfSubscribers = {};\n\tvar mapSubscribersID = {};\n\tvar mapSubscribersTopic = {};\n\tvar mapQueryResponses = {};\n\tvar mapQueryResponseTimeOut = {};\n\tvar clientIDCounter = 1000;\n\tvar clientName;\n\tvar transport = false;\n\tvar isRouterReady = false;\n\tvar isParentWaiting = false;\n\tvar parentReadyCallbackQueue = []; // must be queue because may be multiple waiters\n\tvar self = this;\n\n\t/////////////////////////////////////////////////////////////////////\n\t// Private Message Contructors for Communicating with RouterService\n\t/////////////////////////////////////////////////////////////////////\n\n\tfunction InitialHandshakeMessage() {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"initialHandshake\",\n\t\t};\n\t}\n\tfunction TimeCalibrationHandshakeMessage(clientBaseTime, serviceBaseTime) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"timeCalibration\",\n\t\t};\n\t\tthis.clientBaseTime = clientBaseTime;\n\t\tthis.serviceBaseTime = serviceBaseTime;\n\t}\n\tfunction AddListenerMessage(channel) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"addListener\",\n\t\t\t\"channel\": channel\n\t\t};\n\t}\n\tfunction TransmitMessage(toChannel, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"transmit\",\n\t\t\t\"channel\": toChannel\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction RemoveListenerMessage(channel) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"removeListener\",\n\t\t\t\"channel\": channel\n\t\t};\n\t}\n\tfunction addResponderMessage(channel) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"addResponder\",\n\t\t\t\"channel\": channel\n\t\t};\n\t}\n\tfunction QueryMessage(queryID, channel, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"query\",\n\t\t\t\"queryID\": queryID,\n\t\t\t\"channel\": channel\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction QueryResponseMessage(queryID, error, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"queryResponse\",\n\t\t\t\"queryID\": queryID,\n\t\t\t\"error\": error\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction RemoveResponderMessage(channel) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"removeResponder\",\n\t\t\t\"channel\": channel\n\t\t};\n\t}\n\tfunction SubscribeMessage(subscribeID, topic) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"subscribe\",\n\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\"topic\": topic\n\t\t};\n\t}\n\tfunction UnsubscribeMessage(subscribeID, topic) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"unsubscribe\",\n\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\"topic\": topic\n\t\t};\n\t}\n\tfunction PublishMessage(topic, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"publish\",\n\t\t\t\"topic\": topic\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction NotifyMessage(subscribeID, topic, error, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"notify\",\n\t\t\t\"subscribeID\": subscribeID,\n\t\t\t\"topic\": topic,\n\t\t\t\"error\": error\n\t\t};\n\t\tthis.data = data;\n\t}\n\tfunction AddPubSubResponderMessage(topic) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"addPubSubResponder\",\n\t\t\t\"topic\": topic\n\t\t};\n\t}\n\tfunction RemovePubSubResponderMessage(topic) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"removePubSubResponder\",\n\t\t\t\"topic\": topic\n\t\t};\n\t}\n\tfunction JoinGroupMessage(group) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"joinGroup\",\n\t\t\t\"group\": group\n\t\t};\n\t}\n\tfunction LeaveGroupMessage(group) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"leaveGroup\",\n\t\t\t\"group\": group\n\t\t};\n\t}\n\tfunction GroupTransmitMessage(group, toChannel, message, data) {\n\t\tthis.header = {\n\t\t\t\"origin\": clientName,\n\t\t\t\"type\": \"groupTransmit\",\n\t\t\t\"group\": group,\n\t\t\t\"channel\": toChannel\n\t\t};\n\t\tthis.data = data;\n\t}\n\n\t//////////////////////\n\t// Private Functions\n\t//////////////////////\n\n\t// router client is being terminated so cleanup\n\tfunction destructor(event) {\n\t\tvar finWindow = fin.desktop.Window.getCurrent();\n\t\tLogger.system.info(\"RouterClient: shutting down on event: \" + JSON.stringify(event));\n\t\tself.disconnectAll(); // this will let the router know the client is terminating\n\t\tfinWindow.removeEventListener(\"closed\", destructor);\n\t}\n\n\t// invoked when router init is complete\n\tfunction onReadyCallBack() {\n\t\tLogger.system.debug(\"RouterClient Ready: onReadyCallBack invoked\", self);\n\t\tisRouterReady = true;\n\n\t\t// invoke all the parent callbacks waiting for router to be ready\n\t\twhile (parentReadyCallbackQueue.length > 0) {\n\t\t\tLogger.system.debug(\"RouterClient parentReady invoked\");\n\t\t\tvar nextParentCallback = parentReadyCallbackQueue.shift();\n\t\t\tnextParentCallback();\n\t\t}\n\t}\n\n\t// called once on router-client creation\n\tfunction constructor(thisClientName, transportName) {\n\t\tclientName = thisClientName + \".\" + window.name;\n\t\tconsole.log(\"Router\", clientName);\n\t\tvar callbackCounter = 0;\n\n\t\tfin.desktop.main(function () { // wait for openfin to be ready\n\t\t\tif (callbackCounter++ === 0) { // this check should  not be needed; patch for OpenFin bug which invokes callback twice\n\t\t\t\t// catch \"window closing\" event so can cleanup\n\t\t\t\tvar finWindow = fin.desktop.Window.getCurrent();\n\t\t\t\twindow.addEventListener(\"unload\", destructor); // this is the correct event to catch but\n\t\t\t\tfinWindow.addEventListener(\"closed\", destructor); // this is the correct event to catch but currently doesn't work on mac\n\t\t\t\tConfigUtil.getExpandedRawManifest(function (manifest) {\n\t\t\t\t\tLogger.system.debug(\"Router getExpandedRawManifest\", manifest);\n\t\t\t\t\t//If manifest is a string, then there was an error getting the manifest because in a seperate application\n\t\t\t\t\tif (!manifest || typeof (manifest) === \"string\") {\n\t\t\t\t\t\tLogger.system.error(\"getExpandedRawManifest failed -- fatal error\", manifest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasyncConnectToEventRouter(manifest, clientName, transportName, onReadyCallBack); /**** establish connection to router service ****/\n\t\t\t\t\t}\n\t\t\t\t}, function (err) { Logger.system.error(err); });\n\t\t\t}\n\t\t});\n\t}\n\n\t// connects to event-router service\n\tfunction asyncConnectToEventRouter(manifest, clientName, transportName, onReadyCallBack) {\n\t\tvar transportNotSpecified = (typeof (transportName) === \"undefined\");\n\t\tvar myTimer;\n\t\tvar myRetryCounter = 0;\n\t\tvar isFinished = false;\n\n\t\tvar routerParams = {\n\t\t\trouterDomainRoot: manifest.finsemble.moduleRoot,\n\t\t\trouterSharedWorker: manifest.finsemble.moduleRoot + \"/common/routerSharedWorker.js\",\n\t\t\tforceRouterToOFB: manifest.finsemble.forceRouterToOFB\n\t\t};\n\t\tLogger.system.debug(\"RouterClient\", \"MANIFEST ROUTER PARMAS\", routerParams);\n\n\t\tif (transportNotSpecified) {\n\t\t\ttransport = RouterTransport.getRecommendedTransport(routerParams, incomingMessageHandler, clientName, \"RouterService\")\n\t\t\t\t.then(transportReady)\n\t\t\t\t.catch(errHandler);\n\t\t} else { // tranport specified...typically only for regression testing\n\t\t\ttransport = RouterTransport.getTransport(routerParams, transportName, incomingMessageHandler, clientName, \"RouterService\")\n\t\t\t\t.then(transportReady)\n\t\t\t\t.catch(errHandler);\n\t\t}\n\n\t\tfunction transportReady(transportObj) {\n\t\t\tLogger.system.debug(\"RouterClient: transport ready\", \"TRANSPORT OBJECT\", transportObj);\n\t\t\ttransport = transportObj;\n\t\t\thandshakeHandler = finished; // set function to receive handshake response\n\t\t\tsendHandshake();\n\t\t\tmyTimer = setInterval(sendHandshake, 250); // start time to retry if response not recieved back from router service\n\t\t}\n\n\t\tfunction sendHandshake() {\n\t\t\tLogger.system.debug(\"RouterClient: sendHandshake\");\n\t\t\tsendToRouterService(new InitialHandshakeMessage());\n\t\t\tif (myRetryCounter++ > 20) {\n\t\t\t\tLogger.system.error(\"RouterClient: failure to connect to router service\");\n\t\t\t\tclearInterval(myTimer);\n\t\t\t}\n\t\t}\n\n\t\tfunction finished(transportObj) {\n\t\t\tif (!isFinished) { // ensure only invoked once\n\t\t\t\tLogger.system.debug(\"RouterClient connected: starting \" + clientName + \" with transport \" + transport.identifier());\n\t\t\t\tisFinished = true;\n\t\t\t\tclearInterval(myTimer);\n\t\t\t\tif (queue) { // this should not happen with proper startup order, which waits on routerClient to be ready\n\t\t\t\t\tfor (var i = 0; i < queue.length; i++) {\n\t\t\t\t\t\tLogger.system.debug(\"RouterClient: firing queued msg\");\n\t\t\t\t\t\tvar msg = queue[i];\n\t\t\t\t\t\ttransport.send(msg);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// notify initialization is complete\n\t\t\t\tif (onReadyCallBack) {\n\t\t\t\t\tonReadyCallBack();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction errHandler(errorMessage) {\n\t\t\tLogger.system.error(errorMessage);\n\t\t}\n\t}\n\n\t// provides unique id within one router client for queries\n\tfunction clientID() {\n\t\treturn clientName + \".\" + (++clientIDCounter);\n\t}\n\n\t// returns true if this routerClient originated the message\n\tfunction originatedHere() {\n\t\treturn this.header.origin === this.header.lastClient;\n\t}\n\n\t// invoke client callbacks in the input array (that are attached to a specific channel and listener type)\n\tfunction invokeListenerCallbacks(map, message) {\n\t\tvar clientCallbackArray = map[message.header.channel];\n\t\tif (clientCallbackArray === undefined) {\n\t\t\tLogger.system.warn(\"RouterClient: no listener for incoming transmit on channel \" + message.header.channel + \" from \" + message.header.origin, message);\n\t\t} else {\n\t\t\tmessage.originatedHere = originatedHere;// add local function to test origin\n\t\t\tfor (var i = 0; i < clientCallbackArray.length; i++) { // for each callback defined for the channel\n\t\t\t\tif (!Logger.isLogMessage(message.header.channel)) { // logger messages\n\t\t\t\t\tLogger.system.info(\"RouterClient: incoming transmit\", \"CHANNEL\", message.header.channel, \"FROM\", message.header.origin, \"MESSAGE\", message);\n\t\t\t\t}\n\t\t\t\tclientCallbackArray[i](null, message); // invoke the callback; the error parameter is always null for this case\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction sendQueryResponse(err, responseData) {\n\t\tLogger.system.info(\"RouterClient: outgoing query response\", \"RESPONSE DATA\", responseData, \"QUERY ID\", this.header.queryID);\n\t\tsendToRouterService(new QueryResponseMessage(this.header.queryID, err, responseData));\n\t}\n\n\t// invoke responder-listener callback (attached to a specific channel)\n\tfunction invokeResponderCallback(map, queryMessage) {\n\t\tvar responderCallback = map[queryMessage.header.channel];\n\t\tif (responderCallback === undefined) {\n\t\t\tLogger.system.warn(\"RouterClient: no query responder define on channel \" + queryMessage.header.channel + \" incoming from \" + queryMessage.header.origin, queryMessage);\n\t\t\tresponderCallback(null, queryMessage); // invoke the callback (no error), queryMessage);\n\t\t} else {\n\t\t\tif (!queryMessage.header.error) {\n\t\t\t\tqueryMessage.originatedHere = originatedHere; // add local function to test origin\n\t\t\t\tqueryMessage.sendQueryResponse = sendQueryResponse; // add callback function to message so responder can respond to query\n\t\t\t\tLogger.system.info(\"RouterClient: incoming query\", \"CHANNEL\", queryMessage.header.channel, \"FROM\", queryMessage.header.origin, \"QUERY MESSAGE\", queryMessage);\n\t\t\t\tresponderCallback(null, queryMessage); // invoke the callback (no error)\n\t\t\t} else { // invoke the callback with error since  flag in message (from router service)\n\t\t\t\tLogger.system.warn(\"RouterClient: queryResponder error\", queryMessage);\n\t\t\t\tresponderCallback(queryMessage.header.error, null);\n\t\t\t\tdelete map[queryMessage.header.channel]; // this is a bad responder (e.g. duplicate) so remove it\n\t\t\t}\n\t\t}\n\t}\n\n\t// add a callbackHandler into the query-response map for the given queryID\n\tfunction addQueryResponseCallBack(map, queryID, responseCallback) {\n\t\tmap[queryID] = responseCallback;\n\t}\n\n\t// add timer to wait for query response\n\tfunction addQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID, channel, timeout) {\n\t\tif (timeout > 0) {\n\t\t\tmapQueryResponseTimeOut[newQueryID] = setTimeout(function () {\n\t\t\t\tLogger.system.warn(\"RouterClient: timeout waiting on query response on channel \" + channel + \" for queryID \" + newQueryID +\n\t\t\t\t\t\" on timer \" + mapQueryResponseTimeOut[newQueryID] + \" timeout=\" + timeout);\n\t\t\t}, timeout);\n\t\t}\n\t}\n\n\t// delete timer waiting on query response (if it exists)\n\tfunction deleteQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID) {\n\t\tvar theTimer = mapQueryResponseTimeOut[newQueryID];\n\t\tif (theTimer !== undefined) {\n\t\t\tclearTimeout(theTimer);\n\t\t}\n\t}\n\n\t// invoke query-response callback (that is attached to a specific channel and listener type)\n\tfunction invokeQueryResponseCallback(map, responseMessage) {\n\t\tvar clientCallback = map[responseMessage.header.queryID];\n\t\tif (clientCallback === undefined) {\n\t\t\tLogger.system.warn(\"RouterClient: no handler for incoming query response\", \"QUERY ID\", responseMessage.header.queryID);\n\t\t} else {\n\t\t\t// delete any existing timer waiting on the response\n\t\t\tdeleteQueryResponseTimeout(mapQueryResponseTimeOut, responseMessage.header.queryID);\n\n\t\t\tif (!responseMessage.header.error) {\n\t\t\t\tLogger.system.info(\"RouterClient: incoming query response\", \"RESPONSE MESSAGE\", responseMessage, \"QUERY ID\", responseMessage.header.queryID);\n\t\t\t\tclientCallback(null, responseMessage); // invoke the callback passing the response message\n\t\t\t} else {\n\t\t\t\tLogger.system.warn(\"RouterClient: incoming queryResponse error\", responseMessage.header, \"QUERY ID\", responseMessage.header.queryID);\n\t\t\t\tclientCallback(responseMessage.header.error, responseMessage); // error from router service so pass it back instead of a message\n\t\t\t}\n\t\t\tdelete map[responseMessage.header.queryID];\n\t\t}\n\t}\n\n\t// add responder callbackHandler for the given channel\n\tfunction addResponderCallBack(map, channel, callback) {\n\t\tvar status = false;\n\t\tvar clientCallback = map[channel];\n\t\tif (clientCallback === undefined) {\n\t\t\tmap[channel] = callback;\n\t\t\tstatus = true;\n\t\t}\n\t\treturn status;\n\t}\n\n\t// support function for sendNotifyToSubscriber -- maintains local list of subscribers for pubsub responder\n\tfunction addToPubSubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\n\t\tif (!(topic in pubsubListOfSubscribers)) {\n\t\t\tpubsubListOfSubscribers[topic] = [subscribeID];\n\t\t} else {\n\t\t\tpubsubListOfSubscribers[topic].push(subscribeID);\n\t\t}\n\t}\n\n\t// support function for addPubSubResponder -- add pubsub responder callbackHandler for the given channel\n\tfunction addPubSubResponderCallBack(topic, subscribeCallback, publishCallback, unsubscribeCallback) {\n\t\tvar status = false;\n\t\tvar callbacks = mapPubSubResponders[topic.toString()];\n\t\tif (callbacks === undefined) {\n\t\t\tif (topic instanceof RegExp) {\n\t\t\t\tmapPubSubResponderRegEx[topic.toString()] = topic;\n\t\t\t\tLogger.system.info(\"RouterClient: PubSub RegEx added for topic \" + topic.toString()); // Note: topic may be a RegEx, so use toString() where applicable\n\t\t\t}\n\t\t\tmapPubSubResponders[topic.toString()] = { \"subscribeCallback\": subscribeCallback, \"publishCallback\": publishCallback, \"unsubscribeCallback\": unsubscribeCallback };\n\t\t\tstatus = true;\n\t\t}\n\t\treturn status;\n\t}\n\n\t// callback function for invokeSubscribePubSubCallback to notify new subscriber\n\tfunction sendNotifyToSubscriber(err, notifyData) {\n\t\tsendToRouterService(new NotifyMessage(this.header.subscribeID, this.header.topic, err, notifyData));\n\t\tif (!err) {\n\t\t\t// add new subscriber to list\n\t\t\taddToPubSubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\n\t\t\tLogger.system.info(\"RouterClient: incoming subscription added\", \"TOPIC\", this.header.topic, \"MESSAGE\", this);\n\t\t} else {\n\t\t\tLogger.system.info(\"RouterClient: incoming subscription rejected by pubsub responder\", \"TOPIC\", this.header.topic, \"MESSAGE\", this);\n\t\t}\n\t}\n\n\t// for incoming subscribe: invoke notify callback for pubsub responder\n\tfunction invokeSubscribePubSubCallback(subscribeMessage) {\n\t\tvar callbacks = mapPubSubResponders[subscribeMessage.header.topic];\n\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\n\t\t\tfor (var key in mapPubSubResponderRegEx) {\n\t\t\t\tif (mapPubSubResponderRegEx[key].test(subscribeMessage.header.topic)) {\n\t\t\t\t\tcallbacks = mapPubSubResponders[key];\n\t\t\t\t\tvar initialState = mapPubSubResponderState[subscribeMessage.header.topic]; // may already be initial state defined from publish\n\t\t\t\t\tif (initialState === undefined) { // if there isn't already state defined then use default from regEx\n\t\t\t\t\t\tinitialState = mapPubSubResponderState[key]; // initialize the state from RegEx topic\n\t\t\t\t\t}\n\t\t\t\t\tmapPubSubResponderState[subscribeMessage.header.topic] = initialState;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined) { // if still undefined\n\t\t\tLogger.system.warn(\"RouterClient: no pubsub responder defined for incoming subscribe\", subscribeMessage);\n\t\t} else {\n\t\t\tif (subscribeMessage.header.error) { // the router service uses the subscribe message in this case to return a pubsub error (ToDO: consider a generic error message)\n\t\t\t\tLogger.system.warn(\"RouterClient: pubsub error received from router service: \" + JSON.stringify(subscribeMessage.header.error));\n\t\t\t} else {\n\t\t\t\tsubscribeMessage.sendNotifyToSubscriber = sendNotifyToSubscriber; // add callback function to message so pubsub responder can respond with Notify message\n\t\t\t\tif (callbacks.subscribeCallback) {\n\t\t\t\t\tsubscribeMessage.data = mapPubSubResponderState[subscribeMessage.header.topic];\n\t\t\t\t\tcallbacks.subscribeCallback(null, subscribeMessage); // invoke the callback (no error)\n\t\t\t\t} else { // since no subscribe callback defined, use default functionality\n\t\t\t\t\tsubscribeMessage.sendNotifyToSubscriber(null, mapPubSubResponderState[subscribeMessage.header.topic]); // must invoke from message to set this properly\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// support function for removeSubscriber callback --  remove one subscribeID from array for the given subscription topic\n\tfunction removeFromPubSubListOfSubscribers(pubsubListOfSubscribers, topic, subscribeID) {\n\t\tvar removed = false;\n\t\tif (topic in pubsubListOfSubscribers) {\n\t\t\tvar list = pubsubListOfSubscribers[topic];\n\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\tif (subscribeID === list[i]) {\n\t\t\t\t\tlist.splice(i, 1);\n\t\t\t\t\tif (list.length === 0) {\n\t\t\t\t\t\tdelete pubsubListOfSubscribers[topic];\n\t\t\t\t\t}\n\t\t\t\t\tremoved = true;\n\t\t\t\t\tLogger.system.info(\"RouterClient: PubSub removeListener\", \"TOPIC\", topic, \"FROM\", subscribeID);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!removed) {\n\t\t\tLogger.system.warn(\"RouterClient: tried to remove non-existance listener on \" + topic + \" from \" + JSON.stringify(subscribeID));\n\t\t}\n\t}\n\n\t// callback function for invokeUnsubscribePubSubCallback to remove the subscriber from the subscription\n\tfunction removeSubscriber() {\n\t\tremoveFromPubSubListOfSubscribers(pubsubListOfSubscribers, this.header.topic, this.header.subscribeID);\n\t}\n\n\t// for incoming unsubscribe: invoke unsubscribe callback for pubsub servier\n\tfunction invokeUnsubscribePubSubCallback(unsubscribeMessage) {\n\t\tvar callbacks = mapPubSubResponders[unsubscribeMessage.header.topic];\n\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\n\t\t\tfor (var key in mapPubSubResponderRegEx) {\n\t\t\t\tif (mapPubSubResponderRegEx[key].test(unsubscribeMessage.header.topic)) {\n\t\t\t\t\tcallbacks = mapPubSubResponders[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined) { // if still undefined\n\t\t\tLogger.system.warn(\"RouterClient: no pubsub responder defined for incoming unsubscribe\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n\t\t} else {\n\t\t\tunsubscribeMessage.removeSubscriber = removeSubscriber; // add callback function to message for pubsub responder (but must always remove)\n\t\t\tif (callbacks.unsubscribeCallback) {\n\t\t\t\tLogger.system.info(\"RouterClient: incoming unsubscribe callback\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n\t\t\t\tcallbacks.unsubscribeCallback(null, unsubscribeMessage); // invoke the callback (no error)\n\t\t\t} else { // since no unsubscribe callback defined, use default functionality\n\t\t\t\tLogger.system.info(\"RouterClient: incoming unsubscribe\", \"TOPIC\", unsubscribeMessage.header.topic, \"UNSUBSCRIBE MESSAGE\", unsubscribeMessage);\n\t\t\t\tunsubscribeMessage.removeSubscriber();\n\t\t\t}\n\t\t}\n\t}\n\n\t// callback function for invokePublishPubSubCallback to send Notify\n\tfunction sendNotifyToAllSubscribers(err, notifyData) {\n\t\tif (!err) {\n\t\t\tmapPubSubResponderState[this.header.topic] = notifyData; // store new state\n\t\t\tvar listOfSubscribers = pubsubListOfSubscribers[this.header.topic];\n\t\t\tif (typeof (listOfSubscribers) !== \"undefined\") { // confirm subscribers to send to, if none then nothing to do\n\t\t\t\tfor (var i = 0; i < listOfSubscribers.length; i++) {\n\t\t\t\t\tLogger.system.info(\"RouterClient: sending pubsub notify\", \"TOPIC\", this.header.topic, \"NOTIFY DATA\", notifyData);\n\t\t\t\t\tsendToRouterService(new NotifyMessage(listOfSubscribers[i], this.header.topic, err, notifyData));\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tLogger.system.info(\"RouterClient: income publish rejected by pubsub responder\", err, notifyData);\n\t\t}\n\t}\n\n\t// for incoming Publish: invoke publish callback for pubsub servier\n\tfunction invokePublishPubSubCallback(publishMessage) {\n\t\tvar callbacks = mapPubSubResponders[publishMessage.header.topic];\n\n\t\tif (callbacks === undefined) { // if undefined then may be a matching RegEx topic\n\t\t\tfor (var key in mapPubSubResponderRegEx) {\n\t\t\t\tif (mapPubSubResponderRegEx[key].test(publishMessage.header.topic)) {\n\t\t\t\t\tcallbacks = mapPubSubResponders[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (callbacks === undefined) { // if still undefined\n\t\t\tLogger.system.warn(\"RouterClient: no pubsub responder defined for incoming publish\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n\t\t} else {\n\t\t\tpublishMessage.sendNotifyToAllSubscribers = sendNotifyToAllSubscribers; // add callback function to message so pubsub responder can respond to publish\n\t\t\tif (callbacks.publishCallback) {\n\t\t\t\tLogger.system.info(\"RouterClient: incoming PubSub publish callback invoked\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n\t\t\t\tcallbacks.publishCallback(null, publishMessage); // invoke the callback (no error)\n\t\t\t} else { // since no pubish callback defined, use default functionality\n\t\t\t\tLogger.system.info(\"RouterClient: incoming PubSub publish\", \"TOPIC\", publishMessage.header.topic, \"PUBLISH MESSAGE\", publishMessage);\n\t\t\t\tpublishMessage.sendNotifyToAllSubscribers(null, publishMessage.data); // must call from publish message (like a callback) so 'this' is properly set\n\t\t\t}\n\t\t}\n\t}\n\n\t// for incoming Notify: invoke notify callback (that are attached to a specific channel and listener type)\n\tfunction invokeNotifyCallback(mapSubscribersID, notifyMessage) {\n\t\tvar notifyCallback = mapSubscribersID[notifyMessage.header.subscribeID];\n\t\tif (notifyCallback === undefined) {\n\t\t\tLogger.system.warn(\"RouterClient: no subscription handler defined for incoming notify for subscriberID\", notifyMessage.header.subscribeID, notifyMessage);\n\t\t} else {\n\t\t\tif (!notifyMessage.header.error) {\n\t\t\t\tnotifyMessage.originatedHere = originatedHere;// add local function to test origin\n\t\t\t\tLogger.system.info(\"RouterClient: incoming PubSub notify\", \"SUBSCRIBER ID\", notifyMessage.header.subscribeID, \"NOTIFY MESSAGE\", notifyMessage);\n\t\t\t\tnotifyCallback(null, notifyMessage); // invoke the callback passing the response message\n\t\t\t} else {\n\t\t\t\tLogger.system.info(\"RouterClient: incoming PubSub notify error for subscriberID\", \"SUBSCRIBER ID\", notifyMessage.header.subscribeID, \"NOTIFY MESSAGE\", notifyMessage);\n\t\t\t\tnotifyCallback(notifyMessage.header.error, notifyMessage); // error from router service so pass it back instead of a message\n\t\t\t}\n\t\t}\n\t}\n\n\t// outgoing Unsubscribe: remove subscriber callbackHandler for the given channel\n\tfunction removeSubscriberCallBack(mapSubscribersID, subscribeID) {\n\t\tvar status = false;\n\t\tvar notifyCallback = mapSubscribersID[subscribeID];\n\t\tif (notifyCallback !== undefined) {\n\t\t\tdelete mapSubscribersID[subscribeID];\n\t\t\tstatus = true;\n\t\t}\n\t\treturn status;\n\t}\n\n\t// for outgoing addSubscriber -- add a callback Handler for the subscribe\n\tfunction addSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic) {\n\t\tmapSubscribersID[subscribeID] = notifyCallback;\n\t\tmapSubscribersTopic[subscribeID] = topic;\n\n\t}\n\n\t// for removePubSubResponder: remove responder callbackHandler for the given channel\n\tfunction removeResponderCallBack(map, channel) {\n\t\tvar status = false;\n\t\tvar clientCallback = map[channel];\n\t\tif (clientCallback !== undefined) {\n\t\t\tdelete map[channel];\n\t\t\tstatus = true;\n\t\t}\n\t\treturn status;\n\t}\n\n\t// for addListener: add a callbackHandler into the specified map (which depends on listener type) for the given channel\n\tfunction addListenerCallBack(map, channel, callback) {\n\t\tvar firstChannelClient = false;\n\t\tvar clientCallbackArray = map[channel];\n\t\tif (clientCallbackArray === undefined || clientCallbackArray.length === 0) {\n\t\t\tmap[channel] = [callback];\n\t\t\tfirstChannelClient = true;\n\t\t} else {\n\t\t\tclientCallbackArray.push(callback);\n\t\t}\n\t\treturn firstChannelClient;\n\t}\n\n\t// for removeListener: remove a callbackHandler from the specified map (which depends on listener type) for the given channel\n\tfunction removeListenerCallBack(map, channel, callback) {\n\t\tvar lastChannelClient = false;\n\t\tvar clientCallbackArray = map[channel];\n\t\tif (clientCallbackArray !== undefined) {\n\t\t\tvar index = clientCallbackArray.indexOf(callback);\n\t\t\tif (index > -1) {\n\t\t\t\tclientCallbackArray.splice(index, 1);\n\t\t\t\tif (clientCallbackArray.length === 0) {\n\t\t\t\t\tlastChannelClient = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tLogger.system.warn(\"no listener defined for channel: \" + channel);\n\t\t\t}\n\t\t}\n\t\treturn lastChannelClient;\n\t}\n\n\t// route incoming message to appropriate callback, which depends on the message type and channel\n\tfunction routeIncomingMessage(incomingMessage) {\n\t\tLogger.system.verbose(\"Incoming Message Type\", incomingMessage.header.type, incomingMessage);\n\t\tswitch (incomingMessage.header.type) {\n\t\tcase \"transmit\":\n\t\t\tinvokeListenerCallbacks(mapListeners, incomingMessage);\n\t\t\tbreak;\n\t\tcase \"query\":\n\t\t\tinvokeResponderCallback(mapResponders, incomingMessage);\n\t\t\tbreak;\n\t\tcase \"queryResponse\":\n\t\t\tinvokeQueryResponseCallback(mapQueryResponses, incomingMessage);\n\t\t\tbreak;\n\t\tcase \"notify\":\n\t\t\tinvokeNotifyCallback(mapSubscribersID, incomingMessage);\n\t\t\tbreak;\n\t\tcase \"publish\":\n\t\t\tinvokePublishPubSubCallback(incomingMessage);\n\t\t\tbreak;\n\t\tcase \"subscribe\":\n\t\t\tinvokeSubscribePubSubCallback(incomingMessage);\n\t\t\tbreak;\n\t\tcase \"unsubscribe\":\n\t\t\tinvokeUnsubscribePubSubCallback(incomingMessage);\n\t\t\tbreak;\n\t\tcase \"timeCalibration\":\n\t\t\ttimeCalibrationHandler(incomingMessage);\n\t\t\tbreak;\n\t\tcase \"initialHandshakeResponse\":\n\t\t\thandshakeHandler();\n\t\t\tbreak;\n\t\tdefault:\n\t\t}\n\t}\n\n\t// *** all incoming messages from underlying transport arrive here ***\n\t// although incoming transport information is available, it is not passed on because not needed\n\tfunction incomingMessageHandler(incomingTransportInfo, message) {\n\t\t// ToDo: good place to put a function to validate incoming message/data\n\t\tmessage.header.lastClient = clientName; // add last client for diagnostics\n\t\tmessage.header.incomingTransportInfo = incomingTransportInfo;\n\t\trouteIncomingMessage(message);\n\t}\n\n\t// *** all outbound messages exit here though the appropriate transport ***\n\tfunction sendToRouterService(message) {\n\t\tLogger.system.verbose(\"Outgoing Message\", message.header.type, message);\n\t\tif (!transport || (transport instanceof Promise)) {\n\t\t\tLogger.system.warn(\"RouterClient: Queuing message since router initialization not complete\", message);\n\t\t\tqueue.push(message);\n\t\t} else {\n\t\t\ttransport.send(message);\n\t\t}\n\t}\n\n\n\t/////////////////////////////////////////////\n\t// Public Functions -- The Router Client API\n\t/////////////////////////////////////////////\n\n\t/**\n\t * Get router client name.\n\t *\n\t * @param {string} newClientName string identify the client\n\t * FSBL.Clients.RouterClient.setClientName(\"MyComponent\");\n\t * @private\n\t */\n\tthis.getClientName = function () {\n\t\tLogger.system.debug(\"RouterClient.getClientName\", clientName);\n\t\treturn clientName;\n\t};\n\n\t/**\n\t * Checks if router is ready. May be invoked multiple times. Invokes cb when ready, which may be immediately.  Router is not ready until underlying transport to router service is ready.\n\t *\n\t * @param {function} cb callback function to invoke when router is ready\n\t */\n\tthis.onReady = function (cb) {\n\t\tValidate.args(cb, \"function\");\n\t\tif (isRouterReady) {\n\t\t\tLogger.system.debug(\"Router Ready: invoking parentReady callback\");\n\t\t\tcb();\n\t\t} else {\n\t\t\tLogger.system.debug(\"Router Ready: queuing parentReady callback\");\n\t\t\tparentReadyCallbackQueue.push(cb);\n\t\t}\n\t};\n\n\t/**\n\t * Estimates offset to align the reference time with Router Service.  Does this by exchanging messages with RouterService, getting the service's time, and estimating communication delay.\n\t *\n\t * @private\n\t */\n\tthis.calibrateTimeWithRouterService = function (callback) {\n\t\tconst TARGET_HANDSHAKE_COUNT = 5;\n\t\tvar handshakeCounter = 0;\n\t\tvar timeOffset;\n\t\tvar offsetForFastest;\n\t\tvar fastestRRT = Infinity;\n\n\t\tfunction calibrationCalculation(finalHandshakeMessage) {\n\t\t\tvar timeOffset = 0;\n\t\t\tfor (var i = 1; i < TARGET_HANDSHAKE_COUNT; i++) {\n\t\t\t\tvar startClientTime = finalHandshakeMessage.clientBaseTime[i - 1];\n\t\t\t\tvar stopClientTime = finalHandshakeMessage.clientBaseTime[i];\n\t\t\t\tvar rtt = stopClientTime - startClientTime; // round-trip time\n\t\t\t\tvar serviceTime = finalHandshakeMessage.serviceBaseTime[i - 1];\n\t\t\t\tvar offset = serviceTime - (startClientTime + (rtt / 2));\n\t\t\t\tif (rtt < fastestRRT) {\n\t\t\t\t\tfastestRRT = rtt;\n\t\t\t\t\toffsetForFastest = offset;\n\t\t\t\t}\n\t\t\t\ttimeOffset += offset;\n\t\t\t\tLogger.system.debug(\"calibrationCalculation Intermediate Values\", \"lastRRT\", rtt, \"lastOffset\", offset, \"fastestOffset\", offsetForFastest, \"fastestRRT\", fastestRRT);\n\t\t\t}\n\t\t\ttimeOffset /= (TARGET_HANDSHAKE_COUNT - 1);\n\t\t\tLogger.system.debug(\"RouterClient calibrationCalculation\", \"Average Offset\", timeOffset, \"Choosen FastestOffset\", offsetForFastest, finalHandshakeMessage);\n\t\t\tcallback(offsetForFastest); // use the offset with the shortest RTT since it is often the most accurate\n\t\t}\n\n\t\tfunction timeCalibrationHandlerFunction(message) {\n\t\t\thandshakeCounter++;\n\t\t\tif (handshakeCounter > TARGET_HANDSHAKE_COUNT) {\n\t\t\t\tcalibrationCalculation(message); // enough handshake data gather, so do the calibration\n\t\t\t} else {\n\t\t\t\tmessage.clientBaseTime.push(window.performance.timing.navigationStart + window.performance.now());\n\t\t\t\tsendToRouterService(new TimeCalibrationHandshakeMessage(message.clientBaseTime, message.serviceBaseTime));\n\t\t\t}\n\t\t}\n\n\t\ttimeCalibrationHandler = timeCalibrationHandlerFunction; // used in routeIncomingMessage to route handshake response back to handler\n\t\ttimeCalibrationHandler(new TimeCalibrationHandshakeMessage([], [])); // invoke first time to start exchanging handshakes; will be invoked each time handshake message received back from FouterService\n\t};\n\n\t/**\n\t * Backward compatibility?\n\t */\n\tthis.ready = this.onReady;\n\t/**\n\t * Add listener for incoming transmit events on specified channel. Each of the incoming events will trigger the specified event handler. The number of listeners is not limited (either local to this Finsemble window or in a seperate Finsemble window).\n\t *\n\t * See [transmit]{@link RouterClientConstructor#transmit} for sending a cooresponding event message to listener. See [removeListener]{@link RouterClientConstructor#removeListener} to remove the listener.\n\t *\n\t * @param {string} channel any unique string to identify the channel (must match correspond transmit channel name)\n\t * @param {function} eventHandler function (see example below)\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.addListener(\"SomeChannelName\", function (error, response) {\n\t\t\tif (error) {\n\t\t\t\tLogger.system.log(\"ChannelA Error: ' + JSON.stringify(error));\n\t\t\t} else {\n\t\t\t\tvar data = response.data;\n\t\t\t\tLogger.system.log(\"ChannelA Response: ' + JSON.stringify(response));\n\t\t\t}\n\t * });\n\t *\n\t */\n\tthis.addListener = function (channel, eventHandler) {\n\t\tLogger.system.info(\"RouterClient.addListener\", \"CHANNEL\", channel);\n\t\tValidate.args(channel, \"string\", eventHandler, \"function\");\n\t\tvar firstChannelClient = addListenerCallBack(mapListeners, channel, eventHandler);\n\t\tif (firstChannelClient) {\n\t\t\tsendToRouterService(new AddListenerMessage(channel));\n\t\t}\n\t};\n\n\t/**\n\t * Transmit event to all listeners on the specified channel. If no listeners the event is discarded without error. All listeners to the channel in this Finsemble window and other Finsemble windows will receive the transmit.\n\t *\n\t * See [addListener]{@link RouterClientConstructor#addListener} to add a listener to receive the transmit.\n\t *\n\t * @param {string} toChannel any unique string to identify the channel (must match correspond listener channel name)\n\t * @param {any} event any object or primitive type to be transmitted\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.transmit(\"SomeChannelName\", event);\n\t *\n\t */\n\tthis.transmit = function (toChannel, event) {\n\t\tif (!Logger.isLogMessage(toChannel)) { // logger messages\n\t\t\tLogger.system.info(\"RouterClient.transmit\", \"TO CHANNEL\", toChannel, \"EVENT\", event);\n\t\t}\n\t\tValidate.args(toChannel, \"string\", event, \"any\");\n\t\tsendToRouterService(new TransmitMessage(toChannel, event));\n\t};\n\n\t/**\n\t * Remove event listener from specified channel for the specific event handler (only listeners created locally can be removed).\n\t *\n\t * See [addListener]{@link RouterClientConstructor#addListener} for corresponding add of a listener.\n\t *\n\t * @param {string} channel unique channel name to remove listener from\n\t * @param {function} eventHandler function used for the event handler when the listener was added\n\t */\n\tthis.removeListener = function (channel, eventHandler) {\n\t\tLogger.system.info(\"RouterClient.removelistener\", \"CHANNEL\", channel, \"EVENT HANDLER\", eventHandler);\n\t\tValidate.args(channel, \"string\", eventHandler, \"function\");\n\t\tvar lastChannelListener = removeListenerCallBack(mapListeners, channel, eventHandler);\n\t\tif (lastChannelListener) {\n\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\n\t\t}\n\t};\n\n\t/**\n\t * Add query responder to the specified channel (only one responder allowed per channel within the Finsemble application). The responder's queryEventHander function will receive all incoming queries for the specified channel (whether from this Finsemble window or remote Finsemble windows).\n\t *\n\t * See [query]{@link RouterClientConstructor#query} for sending a corresponding query-event message to this responder.\n\t *\n\t * @param {string} channel any unique string to identify the channel (must match correspond query channel name); only one responder allower per channel\n\t * @param {function} queryEventHandler function to handle the incoming query (see example below); note incoming queryMessage contains function to send response\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.addResponder(\"ResponderChannelName\", function (error, queryMessage) {\n\t *\tif (error) {\n\t *\t\tLogger.system.log('addResponder failed: ' + JSON.stringify(error));\n\t *\t} else {\n\t *\t\t// process income query message\n\t *\t\tqueryMessage.sendQueryResponse(null, queryMessage.data); // A QUERY RESPONSE MUST BE SENT\n\t *\t}\n\t * });\n\t *\n\t */\n\tthis.addResponder = function (channel, queryEventHandler) {\n\t\tLogger.system.info(\"RouterClient.addResponder\", \"CHANNEL\", channel);\n\t\tValidate.args(channel, \"string\", queryEventHandler, \"function\");\n\t\tvar status = addResponderCallBack(mapResponders, channel, queryEventHandler);\n\t\tif (status) {\n\t\t\tsendToRouterService(new addResponderMessage(channel));\n\t\t} else {\n\t\t\tLogger.system.warn(\"RouterClient.addResponder: Responder already locally defined for channel \" + channel);\n\t\t\tqueryEventHandler({\n\t\t\t\t\"RouteClient QueryError\": \"Responder already locally defined for channel\"\n\t\t\t}, null); // immediately invoke callback passing error\n\t\t}\n\t};\n\n\t/**\n\t * Send a query to responder listening on specified channel. The responder may be in this Finsemble window or another Finsemble window.\n\t *\n\t * See [addResponder]{@link RouterClientConstructor#addResponder} to add a responder to receive the query.\n\t *\n\t * @param {any} responderChannel any unique string to identify the channel (must match correspond responder channel name)\n\t * @param {object} queryEvent event message sent to responder\n\t * @param {any=} params this object currently can carry only a timeout value (e.g. { timeout: 3000 }) for a query-response timer.  Timer defaults to 5000 milliseconds is no params value is passed in.  A timer is set only when timeout > 0. If the timer expires, only a warning message is display for diagnostics.\n\t * @param {function} responseEventHandler event handler to receive in query response (sent from the responder for the specified channel)\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.query(\"someChannelName\", {}, function (error, queryResponseMessage) {\n\t *\tif (error) {\n\t *\t\tLogger.system.log('query failed: ' + JSON.stringify(error));\n\t *\t} else {\n\t *\t\t// process income query response message\n\t *\t\tvar responseData = queryResponseMessage.data;\n\t *\t\tLogger.system.log('query response: ' + JSON.stringify(queryResponseMessage));\n\t *\t}\n\t * });\n\t *\n\t * FSBL.Clients.RouterClient.query(\"someChannelName\", { queryKey: \"abc123\"}, { timeout: 1000 }, function (error, queryResponseMessage) {\n\t *\tif (!error) {\n\t *\t\t// process income query response message\n\t *\t\tvar responseData = queryResponseMessage.data;\n\t *\t}\n\t * }); */\n\tthis.query = function (responderChannel, queryEvent, params, responseEventHandler) {\n\t\tvar newQueryID = clientID();\n\t\tvar timestamp = window.performance.timing.navigationStart + window.performance.now();\n\t\tvar navstart = window.performance.timing.navigationStart;\n\t\tvar timenow = window.performance.now(); // these timer values used for logging diagnostices\n\n\t\tLogger.system.info(\"RouterClient.query\", \"RESPONDER CHANNEL\", responderChannel, \"QUERY EVENT\", queryEvent, \"PARAMS\", params, \"QUERYID\", newQueryID, { timestamp, navstart, timenow });\n\t\tif (arguments.length === 3) {\n\t\t\tresponseEventHandler = params;\n\t\t\tparams = { timeout: 5000 };\n\t\t}\n\t\tValidate.args(responderChannel, \"string\", queryEvent, \"any=\", params, \"object=\", responseEventHandler, \"function\");\n\t\tparams = params || {};\n\t\tValidate.args2(\"params.timeout\", params.timeout, \"number\");\n\n\t\taddQueryResponseCallBack(mapQueryResponses, newQueryID, responseEventHandler);\n\t\taddQueryResponseTimeout(mapQueryResponseTimeOut, newQueryID, responderChannel, params.timeout);\n\t\tsendToRouterService(new QueryMessage(newQueryID, responderChannel, queryEvent));\n\t};\n\n\t/**\n\t * Remove query responder from specified channel. Only a locally added responder can be removed (i.e. a responder defined in the same component or service).\n\t *\n\t * See [addResponder]{@link RouterClientConstructor#addResponder} for corresponding add of a query responder.\n\t *\n\t * @param {string} responderChannel string identifying the channel to remove responder from\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.removeResponder(\"someChannelName\");\n\t *\n\t */\n\tthis.removeResponder = function (responderChannel) {\n\t\tLogger.system.info(\"RouterClient.removeResponder\", \"RESPONDER CHANNEL\", responderChannel);\n\t\tValidate.args(responderChannel, \"string\");\n\t\tvar status = removeResponderCallBack(mapResponders, responderChannel);\n\t\tif (status) {\n\t\t\tsendToRouterService(new RemoveResponderMessage(responderChannel));\n\t\t}\n\t};\n\n\t/**\n\t * Add a PubSub responder for specified topic. All subscribes and publishes to the topic will comes to responder (whether from local window or another window). Only one PubSub responder allowed per topic value in Finsemble application; however, the topic value may be a regular-expression representing a set of related topics, in which case the PubSub responder will responder to all matching topics. When a regEx topic is used, the same default functionality is provides for each matching topic -- the difference is only one PubSub responder is needed to cover a set of related topics, plus the same callback handers can be used (if provided).\n\t *\n\t * All the callback function are optional because each PubSub responder comes with build-in default functionality (described below).\n\t *\n\t * Note an exact topic match will take precedence over a regEx match, but otherwise results are unpredictable for overlapping RegEx topics.\n\t *\n\t * See [subscribe]{@link RouterClientConstructor#subscribe} and [publish]{@link RouterClientConstructor#publish} for corresponding functions sending to the PubSub responder.\n\t *\n\t * @param {string} topic unique topic for this responder, or a topic RegEx (e.g. '/abc.+/') to handle a set of topics\n\t * @param {object} initialState initial state for the topic (defaults to empty struct); can be any object\n\t * @param {object=} params optional parameters\n\t * @param {function=} params.subscribeCallback allows responder know of incoming subscription and accept or reject it (default is to accept)\n\t * @param {function=} params.publishCallback allows responder to use the publish data to form a new state (default is the publish data becomes the new state)\n\t * @param {function=} params.unsubscribeCallback allows responder to know of the unsubscribe, but it must be accepted (the default accepts)\n\t * @param {function=} callback optional callback(err,res) function. If addPubSubResponder failed then err set; otherwise, res set to \"success\"\n\t *\n\t * @example\n\t *\n\t * function subscribeCallback(error, subscribe) {\n\t * \tif (subscribe) {\n\t * \t\t// must make this callback to accept or reject the subscribe (default is to accept). First parm is err and second is the initial state\n\t * \t\tsubscribe.sendNotifyToSubscriber(null, { \"NOTIFICATION-STATE\": \"One\" });\n\t * \t}\n\t * }\n\t * function publishCallback(error, publish) {\n\t * \tif (publish) {\n\t * \t\t// must make this callback to send notify to all subscribers (if error parameter set then notify will not be sent)\n\t * \t\tpublish.sendNotifyToAllSubscribers(null, publish.data);\n\t * \t}\n\t * }\n\t * function unsubscribeCallback(error, unsubscribe) {\n\t * \tif (unsubscribe) {\n\t * \t\t// must make this callback to acknowledge the unsubscribe\n\t * \t\tunsubscribe.removeSubscriber();\n\t * \t}\n\t * }\n\t * FSBL.Clients.RouterClient.addPubSubResponder(\"topicABC\", { \"State\": \"start\" },\n\t * \t{\n\t * \t\tsubscribeCallback:subscribeCallback,\n\t * \t\tpublishCallback:publishCallback,\n\t * \t\tunsubscribeCallback:unsubscribeCallback\n\t * \t});\n\t *\n\t *   or\n\t *\n\t * FSBL.Clients.RouterClient.addPubSubResponder(\"topicABC\", { \"State\": \"start\" });\n\t *\n\t *   or\n\t *\n\t * FSBL.Clients.RouterClient.addPubSubResponder(\\/topicA*\\/, { \"State\": \"start\" });\n\t *\n\t */\n\tthis.addPubSubResponder = function (topic, initialState, params, callback) {\n\t\tvar error;\n\t\tvar response;\n\t\tLogger.system.info(\"RouterClient.addPubSubResponder\", \"TOPIC\", topic, \"INITIAL STATE\", initialState, \"PARAMS\", params);\n\t\tValidate.args(topic, \"any\", initialState, \"object=\", params, \"object=\");\n\t\tparams = params || {};\n\t\tValidate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\n\t\t\tValidate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\n\n\t\tvar status = addPubSubResponderCallBack(topic, params.subscribeCallback, params.publishCallback, params.unsubscribeCallback);\n\t\tif (status) {\n\t\t\tinitialState = initialState || {};\n\t\t\tmapPubSubResponderState[topic.toString()] = Utils.clone(initialState);\n\t\t\tsendToRouterService(new AddPubSubResponderMessage(topic.toString()));\n\t\t\tresponse = \"success\";\n\t\t} else {\n\t\t\terror = \"RouterClient.addPubSubResponder: Responder already locally defined for topic \" + topic;\n\t\t\tLogger.system.warn(error);\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback(error, response);\n\t\t}\n\t};\n\n\t/**\n\t * Remove pubsub responder from specified topic. Only locally created responders (i.e. created in local window) can be removed.\n\t *\n\t * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder.\n\t *\n\t * @param {string} topic unique topic for responder being removed (may be RegEx, but if so much be exact regEx used previously with addPubSubResponder)\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.removePubSubResponder(\"topicABC\");\n\t *\n\t */\n\tthis.removePubSubResponder = function (topic) {\n\t\tLogger.system.info(\"RouterClient.removePubSubResponder\", \"TOPIC\", topic);\n\t\tValidate.args(topic, \"any\");\n\t\tvar status = removeResponderCallBack(mapPubSubResponders, topic);\n\t\tif (status) {\n\t\t\tdelete mapPubSubResponderState[topic.toString()]; // remove corresponding state\n\t\t\tdelete mapPubSubResponderRegEx[topic.toString()]; // may be a RegEx\n\t\t\tsendToRouterService(new RemovePubSubResponderMessage(topic));\n\t\t} else {\n\t\t\tLogger.system.warn(\"RouterClient.removePubSubResponder failed: Could not find responder for topic \" + topic);\n\t\t}\n\t};\n\n\t/**\n\t * Subscribe to a PubSub Responder. Each responder topic can have many subscribers (local in this window or remote in other windows). Each subscriber immediately (but asyncronouly) receives back current state in a notify; new notifys are receive for each publish sent to the same topic.\n\t *\n\t * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder to handle the subscribe. See [publish]{@link RouterClientConstructor#publish} for corresponding publish to notify the subscriber.\n\t *\n\t * @param {string} topic topic being subscribed to\n\t * @param {function} notifyCallback invoked for each income notify for the given topic (i.e. initial notify plus for each publish)\n\t * @returns subscribe-id object optionally used for unsubscribing later\n\t *\n\t * @example\n\t *\n\t * var subscribeId = RouterClient.subscribe(\"topicABC\", function(err,notify) {\n\t *\t\tif (!err) {\n\t *\t\t\tvar notificationStateData = notify.data;\n\t *\t\t\t// do something with notify data\n\t *  \t}\n\t * });\n\t *\n\t */\n\tthis.subscribe = function (topic, notifyCallback) {\n\t\tLogger.system.info(\"RouterClient.subscribe\", \"TOPIC\", topic);\n\t\tValidate.args(topic, \"string\", notifyCallback, \"function\");\n\t\tvar subscribeID = clientID();\n\t\taddSubscriberCallBack(mapSubscribersID, subscribeID, notifyCallback, topic);\n\t\tsendToRouterService(new SubscribeMessage(subscribeID, topic));\n\t\treturn { \"subscribeID\": subscribeID, \"topic\": topic };\n\t};\n\n\t/**\n\t * Publish to a PubSub Responder, which will trigger a corresponding Notify to be sent to all subscribers (local in this window or remote in other windows). There can be multiple publishers for a topic (again, in same window or remote windows)\n\t *\n\t * See [addPubSubResponder]{@link RouterClientConstructor#addPubSubResponder} for corresponding add of a SubPub responder to handle the publish (i.e. sending notifications to all subscriber). See [Subscribe]{@link RouterClientConstructor#addPubSubResponder} for corresponding subscription to receive publish results (in the form of a notify event)\n\t *\n\t * @param {string} topic topic being published to\n\t * @param {object} event topic state to be published to all subscriber (unless the SubPub responder optionally modifies in between)\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.publish(\"topicABC\", topicState);\n\t *\n\t */\n\tthis.publish = function (topic, event) {\n\t\tLogger.system.info(\"RouterClient.publish\", \"TOPIC\", topic, \"EVENT\", event);\n\t\tValidate.args(topic, \"string\", event, \"any\");\n\t\tsendToRouterService(new PublishMessage(topic, event));\n\t};\n\n\t/**\n\t * Unsubscribe from PubSub responder so no more notifications received (but doesn't affect other subscriptions). Only works from the window the PubSub responder was created in.\n\t *\n\t * See [subscribe]{@link RouterClientConstructor#subscribe} for corresponding subscription being removed.\n\t *\n\t * @param {object} subscribeID the id return from the corresponding subscribe for the topic\n\t *\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.unsubscribe(subscribeId);\n\t *\n\t */\n\tthis.unsubscribe = function (subscribeIDStruct) {\n\t\tLogger.system.info(\"RouterClient.unsubscribe\", \"SUBSCRIBE ID\", subscribeIDStruct);\n\t\tValidate.args(subscribeIDStruct, \"object\") && Validate.args2(\"subscribeIDStruct.subscribeID\", subscribeIDStruct.subscribeID, \"string\");\n\t\tvar deletedSubscriber = removeSubscriberCallBack(mapSubscribersID, subscribeIDStruct.subscribeID);\n\t\tif (deletedSubscriber) {\n\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeIDStruct.subscribeID, subscribeIDStruct.topic));\n\t\t} else {\n\t\t\tLogger.system.warn(\"RouterClient.unsubscribe: Could not find subscribeID for topic \" + subscribeIDStruct.topic);\n\t\t}\n\t};\n\n\t/**\n\t * Test an incoming router message to see if it originated from the same origin (e.g. a trusted source...not cross-domain). Currently same origin is known only because a sharedWorker transport is used (by definition SharedWorkers do not work cross-domain).  This means any message coming in over the OpenFin IAB will not be trusted; however, by default all same-origin components and services connect to the router using a SharedWorker transport.\n\t *\n\t * @param {object} incomingMessage an incoming router message (e.g. transmit, query, notification) to test to see if trusted.\n\t *\n\t * @returns true if message is same origin (i.e. received over SharedWorker transport).\n\t * @example\n\t *\n\t * FSBL.Clients.RouterClient.trustedMessage(incomingRouterMessage);\n\t *\n\t */\n\tthis.trustedMessage = function (incomingMessage) {\n\t\tvar isTrusted = false;\n\t\tLogger.system.debug(\"RouterClient.trustedMessage\", incomingMessage);\n\t\tif (incomingMessage.header.incomingTransportInfo.transportID === \"SharedWorker\") {\n\t\t\tisTrusted = true;\n\t\t}\n\t\treturn isTrusted;\n\t};\n\n\t/*\n\t * @TODO: consider adding disconnectAllListerns(), disconnectAllResponders(), disconnectAllSubscribers()\n\t*/\n\n\t/**\n\t * Removes all listeners, responders, and subscribers for this router client -- automatically called when client is shutting down. Can be called multiple times.\n\t */\n\tthis.disconnectAll = function () {\n\t\tLogger.system.info(\"RouterClient.disconnectAll\");\n\t\tfor (var channel in mapListeners) {\n\t\t\tLogger.system.debug(\"RouterClient.disconnectAll is removing listener on \" + channel);\n\t\t\tsendToRouterService(new RemoveListenerMessage(channel));\n\t\t\tdelete mapListeners[channel];\n\t\t}\n\n\t\tfor (var responderChannel in mapResponders) {\n\t\t\tLogger.system.debug(\"RouterClient.disconnectAll is removing responder on \" + responderChannel);\n\t\t\tsendToRouterService(new RemoveResponderMessage(responderChannel));\n\t\t\tdelete mapResponders[responderChannel];\n\t\t}\n\n\t\tfor (var topic in mapPubSubResponders) {\n\t\t\tLogger.system.debug(\"RouterClient.disconnectAll is removing pubsub responder on \" + topic);\n\t\t\tsendToRouterService(new RemovePubSubResponderMessage(topic));\n\t\t\tdelete mapPubSubResponders[topic.toString()]; // could be a RegEx\n\t\t\tdelete mapPubSubResponderState[topic.toString()]; // remove corresponding state\n\t\t\tdelete mapPubSubResponderRegEx[topic.toString()]; // may be a RegEx\n\t\t}\n\n\t\tfor (var subscribeID in mapSubscribersID) {\n\t\t\tvar stopic = mapSubscribersTopic[subscribeID];\n\t\t\tLogger.system.debug(\"RouterClient.disconnectAll is removing subscriber on \" + stopic);\n\t\t\tsendToRouterService(new UnsubscribeMessage(subscribeID, stopic));\n\t\t\tdelete mapSubscribersID[subscribeID];\n\t\t\tdelete mapSubscribersTopic[subscribeID];\n\t\t}\n\t};\n\n\tconstructor(thisClientName, transportName); // on creation invoke to initialize\n};\n\nmodule.exports = RouterClientConstructor;\n\n\n\n// WEBPACK FOOTER //\n// ./src/clients/routerClientConstructor.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\nvar SystemSettings = require(\"../common/systemSettings\");\nvar Logger = require('../clients/logger');\nmodule.exports = {\n\t/**\n\t * Gets the openfin version in object form.\n\t */\n\tgetOpenfinVersion: function (cb) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfin.desktop.System.getVersion((ver) => {\n\t\t\t\tlet verArr = ver.split('.').map(Number);\n\t\t\t\tlet versionObject = {\n\t\t\t\t\tmajor: verArr[0],\n\t\t\t\t\tchromium: verArr[1],\n\t\t\t\t\tminor: verArr[2],\n\t\t\t\t\tpatch: verArr[3]\n\t\t\t\t};\n\t\t\t\tconsole.log(versionObject);\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb(versionObject);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(versionObject);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\t/**\n\t * Given a function _that returns a value_, this method will return a thenable object.\n\t * **NOTE** This will not work if your function doesn't return something.\n\t *  <example>\n\t *\t\tfunction myFunc(){\n\t\t\t\tconsole.log('I promise that this is not a promise.');\n\t\t\t }\n\t\tlet myPromise = util.castToPromise(myFunc);\n\t\tmyPromise().then(doSomethingElse);\n\t\t</example>\n\n\t */\n\tcastToPromise: function (f) {\n\t\treturn function () {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t//Calls f, checks to see if the returned object has a `then` method. if not, it will resolve the result from the intiial function.\n\t\t\t\tconst result = f.apply(null, Array.from(arguments));\n\t\t\t\ttry {\n\t\t\t\t\treturn result.then(resolve, reject);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e instanceof TypeError) {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t},\n\t/**\n\t * @introduction\n\t * <h2>Finsemble Utility Functions</h2>\n\t * @private\n\t * @class Utils\n\t */\n\n\tisPercentage: function (val) {\n\t\tif (typeof (val) !== \"string\") {\n\t\t\treturn false;\n\t\t}\n\t\treturn val.indexOf(\"%\") !== -1;\n\t},\n\n\tretrieveMonitorDimensions: function (callback) {\n\t\tvar dims = {};\n\t\tvar b = {};\n\t\tthis.getMonitorInfo().then(function (monitorInfo) {\n\t\t\tvar availableMonitors = [monitorInfo.primaryMonitor].concat(monitorInfo.nonPrimaryMonitors);\n\t\t\tfin.desktop.Window.getCurrent().getBounds(function (bounds) {\n\t\t\t\tdims.defaultLeft = bounds.left;\n\t\t\t\tdims.defaultTop = bounds.top;\n\t\t\t\tb = bounds;\n\t\t\t\tfindMonitor();\n\t\t\t});\n\t\t\tfunction findMonitor() {\n\t\t\t\tfor (var i = 0; i < availableMonitors.length; i++) {\n\t\t\t\t\tvar monitor = availableMonitors[i].availableRect;\n\n\t\t\t\t\tmonitor.width = monitor.right - monitor.left;\n\t\t\t\t\tmonitor.height = monitor.bottom - monitor.top;\n\t\t\t\t\tif (dims.defaultLeft >= monitor.left && dims.defaultLeft < monitor.right) {\n\t\t\t\t\t\tdims.monitorDimensions = monitor;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(null, dims);\n\t\t\t\t}\n\t\t\t}\n\n\t\t});\n\t},\n\n\t/**\n * finsemble console for displaying diagnostic messages (a transparent replacement for window.top.console)\n * @param {string} name prefix for all console output\n * @memberof Utils\n * @constructor\n */\n\tConsole: function (name) {\n\n\t\tvar consoleName;\n\n\t\t// returns a trace substring\n\t\t// The \"sub\" parameter indicates function to start displaying trace from (i.e. truncate trace previous to this function)\n\t\tfunction traceString(sub) {\n\t\t\tfunction getErrorObject() {\n\t\t\t\ttry { throw Error(''); } catch (err) { return err; }\n\t\t\t}\n\t\t\tvar tString = getErrorObject().stack;\n\t\t\ttString = tString.substring(tString.indexOf(\"at \" + sub) - 5); // extra 5 chars to align formating\n\t\t\treturn tString;\n\t\t}\n\n\t\t/**\n\t\t * Pass through function for console.error, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 1\n\t\t *\n\t\t */\n\t\tthis.error = function () {\n\t\t\tvar myLevel = 1;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Error: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = traceString(\"error\") + \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.error.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function for console.warn, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 2\n\t\t *\n\t\t */\n\t\tthis.warn = function () {\n\t\t\tvar myLevel = 2;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Warn: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = traceString(\"warn\") + \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.warn.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function for console.info, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 3\n\t\t *\n\t\t */\n\t\tthis.info = function () {\n\t\t\tvar myLevel = 3;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Info: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.info.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function for console.log (but redirected to console.info), with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 3\n\t\t *\n\t\t */\n\t\tthis.log = function () {\n\t\t\tvar myLevel = 3;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Log: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.info.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function for console.debug, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 4\n\t\t *\n\t\t */\n\t\tthis.debug = function () {\n\t\t\tvar myLevel = 4;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Debug: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.debug.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 5\n\t\t *\n\t\t */\n\t\tthis.debug2 = function () {\n\t\t\tvar myLevel = 5;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Debug2: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.debug.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 6\n\t\t *\n\t\t */\n\t\tthis.debug3 = function () {\n\t\t\tvar myLevel = 6;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Debug3: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.debug.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * Pass through function to console.debug, with Finsemble info inserted to front and end of output.\n\t\t * All output ignored unless SystemSetting.diagLevel() >= 7\n\t\t *\n\t\t */\n\t\tthis.debug4 = function () {\n\t\t\tvar myLevel = 7;\n\t\t\tif (myLevel <= SystemSettings.diagLevel()) {\n\t\t\t\tvar args = [].slice.call(arguments); //Convert to a real array\n\t\t\t\tvar preface = consoleName + \" Debug4: \";\n\t\t\t\targs.unshift(preface);\n\t\t\t\tvar suffix = \" (timestamp \" + Math.round((window.performance.now() * 1000)) / 1000 + ')';\n\t\t\t\targs.push(arguments, suffix);\n\t\t\t\twindow.top.console.debug.apply(console, args);\n\t\t\t}\n\t\t};\n\n\t\tconsoleName = name;\n\t\tif (window.top !== window) {\n\t\t\tconsoleName += ' Frame';\n\t\t}\n\t},\n\n\t/**\n\t * @param {any} name\n\t * @param {any} payload\n\t * @memberof Utils\n\t */\n\tmsgWrapper: function (name, payload) {\n\t\tthis.name = name;\n\t\tthis.payload = payload;\n\t},\n\n\tmonitorInfo: null,\n\t/**\n\t * returns monitor infor\n\t *\n\t * @param {any} force\n\t * @returns object\n\t */\n\tgetMonitorInfo: function (force) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\n\t\t\t\tconsole.debug(\"getMonitorInfo\");\n\t\t\t\tmodule.exports.monitorInfo = monitorInfo;\n\t\t\t\tresolve(monitorInfo);\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * get the dimensions of a monitor\n\t *\n\t * @returns height and weight\n\t * @memberof Utils\n\t */\n\tgetMonitorDimensions: function () {\n\t\treturn new Promise(\n\t\t\tfunction (resolve, reject) {\n\t\t\t\tconsole.debug(\"getMonitorDimensions\");\n\t\t\t\tvar monitorDimensions = {\n\t\t\t\t\theight: null,\n\t\t\t\t\twidth: null\n\n\t\t\t\t};\n\t\t\t\tconsole.debug('getting data');\n\t\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\n\t\t\t\t\tconsole.debug('got monitorInfo', monitorInfo);\n\t\t\t\t\t//top bar is 45..\n\t\t\t\t\tmonitorDimensions.height = monitorInfo.primaryMonitor.availableRect.bottom - monitorInfo.primaryMonitor.availableRect.top - 32;\n\t\t\t\t\tmonitorDimensions.width = monitorInfo.primaryMonitor.availableRect.right;\n\t\t\t\t\tmonitorDimensions.left = monitorInfo.primaryMonitor.availableRect.left;\n\t\t\t\t\tmonitorDimensions.top = monitorInfo.primaryMonitor.availableRect.top;\n\t\t\t\t\tresolve(monitorDimensions);\n\t\t\t\t});\n\t\t\t}\n\t\t);\n\t},\n\n\t/**\n\t * Gets an array of monitor descriptors. Essentially rationalizing the results of OpenFin getMonitorInfo.\n\t * into a single array with additional information added.\n\t *\n\t * whichMonitor is set to the secondary monitor number, or \"primary\" if the primary monitor.\n\t * position is set to a zero index, where primary is the zero position, and each non-primary increments thereafter.\n\t *\n\t * Additionally, width and height are calculated and filled in for availableRect and monitorRect.\n\t *\n\t * @param {callback-array} cb Returns a list of monitor descriptors (optional or use promise)\n\t * @returns {Promise} A promise that resolves to a list of monitor descriptors\n\t */\n\tgetAllMonitors: function (cb) {\n\t\treturn new Promise(function (resolve) {\n\t\t\tfin.desktop.System.getMonitorInfo(function (monitorInfo) {\n\t\t\t\t//console.log(\"getAllMonitors\");\n\t\t\t\tvar allMonitors = [];\n\t\t\t\tvar primaryMonitor = module.exports.clone(monitorInfo.primaryMonitor);\n\t\t\t\tprimaryMonitor.whichMonitor = \"primary\";\n\t\t\t\tprimaryMonitor.position = 0;\n\t\t\t\tallMonitors.push(primaryMonitor);\n\t\t\t\tfor (let i = 0; i < monitorInfo.nonPrimaryMonitors.length; i++) {\n\t\t\t\t\tlet monitor = monitorInfo.nonPrimaryMonitors[i];\n\t\t\t\t\tmonitor.whichMonitor = i;\n\t\t\t\t\tmonitor.position = i + 1;\n\t\t\t\t\tallMonitors.push(module.exports.clone(monitor));\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < allMonitors.length; i++) {\n\t\t\t\t\tlet monitor = allMonitors[i];\n\t\t\t\t\tmodule.exports.rationalizeMonitor(monitor);\n\t\t\t\t}\n\t\t\t\tif (cb) { cb(allMonitors); }\n\t\t\t\tresolve(allMonitors);\n\t\t\t});\n\t\t});\n\t},\n\n\trationalizeMonitor: function (monitor) {\n\t\tmonitor.monitorRect.width = monitor.monitorRect.right - monitor.monitorRect.left;\n\t\tmonitor.monitorRect.height = monitor.monitorRect.bottom - monitor.monitorRect.top;\n\t\tmonitor.availableRect.width = monitor.availableRect.right - monitor.availableRect.left;\n\t\tmonitor.availableRect.height = monitor.availableRect.bottom - monitor.availableRect.top;\n\t},\n\t/**\n\t * Retrieves a monitor descriptor given an absolute X Y on the OpenFin virtual screen\n\t * @param  {number} x The x position\n\t * @param  {number} y The y position\n\t * @param {callback-object}  cb Returns the monitor information from OpenFin.\n\t * \"isPrimary\" is set to true if it's the primary monitor.\n\t * null is returned if the x,y coordinates are beyond the bounds of the virtual screen.\n\t */\n\tgetMonitorFromOpenFinXY: function (x, y, cb) {\n\t\tmodule.exports.getAllMonitors(function (monitors) {\n\t\t\t//\tconsole.log(\"getMonitorFromOpenFinXY\");\n\t\t\tfor (var i = 0; i < monitors.length; i++) {\n\t\t\t\tvar monitor = monitors[i];\n\t\t\t\tvar monitorRect = monitor.monitorRect;\n\t\t\t\t// Are our coordinates inside the monitor? Note that\n\t\t\t\t// left and top are inclusive. right and bottom are exclusive\n\t\t\t\t// In OpenFin, two adjacent monitors will share a right and left pixel value!\n\t\t\t\tif (x >= monitorRect.left && x < monitorRect.right &&\n\t\t\t\t\ty >= monitorRect.top && y < monitorRect.bottom) {\n\t\t\t\t\tcb(monitor);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcb(null);\n\t\t});\n\t},\n\n\t/**\n\t * Retrieves a monitor descriptor for a window. If the window straddles two monitors\n\t * then the monitor from the top left is provided and \"straddling\" flag is set to true.\n\t *\n\t * @param  {LauncherClient~windowDescriptor}   windowDescriptor A windowDescriptor\n\t * @param  {Function} cb               Returns a monitor descriptor (optional or use promise)\n\t * @returns {Promise} A promise that resolves to a monitor descriptor\n\t */\n\tgetMonitorFromWindow: function (windowDescriptor, cb) {\n\t\tvar x = windowDescriptor.x || windowDescriptor.defaultLeft;\n\t\tvar y = windowDescriptor.y || windowDescriptor.defaultTop;\n\t\tvar x2 = x + windowDescriptor.defaultWidth;\n\t\tvar y2 = y + windowDescriptor.defaultHeight;\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tmodule.exports.getMonitorFromOpenFinXY(x, y, function (monitor) {\n\t\t\t\tconsole.debug(\"getMonitorFromWindow\");\n\t\t\t\tif (!monitor) {\n\t\t\t\t\tconsole.log(\"getMonitorFromWindow invariant. Can't find monitor for window\");\n\t\t\t\t\tif (cb) {\n\t\t\t\t\t\tcb(null);\n\t\t\t\t\t}\n\t\t\t\t\treject(new Error('Cannot find monitor for window.'));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmonitor = module.exports.clone(monitor);\n\t\t\t\tvar monitorRect = monitor.monitorRect;\n\t\t\t\tif (monitorRect.right > x2 || monitorRect.bottom > y2) {\n\t\t\t\t\tmonitor.straddling = true;\n\t\t\t\t}\n\t\t\t\tif (cb) { cb(monitor); }\n\t\t\t\tresolve(monitor);\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Returns a finWindow or null if not found\n\t * @param  {LauncherClient~windowIdentifier}   windowIdentifier A window identifier\n\t * @param  {Function} cb               Optional callback containing finWindow or null if not found (or use Promise)\n\t * @return {Promise}                    Promise that resulves to a finWindow or rejects if not found\n\t */\n\tgetFinWindow: function (windowIdentifier, cb) {\n\t\tconsole.debug(\"getFinWindow\");\n\t\tLogger.system.log('Util.getFinWindow - start');\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\t// Default to current window\n\t\t\tvar myWindow = fin.desktop.Window.getCurrent();\n\n\t\t\t// Get OpenFin options (windowDescriptor) for current window\n\t\t\t// we need this info even if we're going to reference a different window\n\t\t\tLogger.system.log('Util.getFinWindow.getOptions - start');\n\t\t\tmyWindow.getOptions(function (options) {\n\t\t\t\tLogger.system.log('Util.getFinWindow.getOptions - callback');\n\t\t\t\t// If windowName is provided, then find that window\n\t\t\t\tif (windowIdentifier && windowIdentifier.windowName) {\n\t\t\t\t\t// If we didn't get a uuid from the caller, then assume\n\t\t\t\t\t// it's the same window as current window\n\t\t\t\t\tif (!windowIdentifier.uuid) {\n\t\t\t\t\t\twindowIdentifier.uuid = options.uuid;\n\t\t\t\t\t}\n\t\t\t\t\t/**\n\t\t\t\t\t * Try to wrap the window; if it exists, getInfo will get in\n\t\t\t\t\t *  to the success function. If not, it'll go into the error callback.\n\t\t\t\t\t */\n\t\t\t\t\tlet remoteWindow = fin.desktop.Window.wrap(windowIdentifier.uuid, windowIdentifier.windowName);\n\t\t\t\t\tLogger.system.log('Util.getFinWindow.remoteWindow.getInfo - Start');\n\t\t\t\t\tremoteWindow.getInfo((info) => {\n\t\t\t\t\t\tLogger.system.log('Util.getFinWindow.remoteWindow.getInfo - callback');\n\t\t\t\t\t\tif (cb) { cb(remoteWindow); };\n\n\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 462');\n\t\t\t\t\t\tresolve(remoteWindow);\n\t\t\t\t\t}, function (err) {\n\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 465');\n\t\t\t\t\t\tif (cb) { cb(null); }\n\t\t\t\t\t\treject(\"Window \" + windowIdentifier.windowName + \" not found.\" + `UUID: ${windowIdentifier.uuid}`);\n\t\t\t\t\t\tconsole.debug(\"util.getFinWindow: Window \" + windowIdentifier.windowName + \" not found\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t});\n\t\t\t\t} else if (windowIdentifier && windowIdentifier.componentType) {\n\t\t\t\t\tif (typeof LauncherService !== 'undefined') {\n\t\t\t\t\t\tlet remoteWindow = LauncherService.componentFinder(windowIdentifier);\n\t\t\t\t\t\tif (remoteWindow) {\n\t\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 475');\n\t\t\t\t\t\t\tresolve(remoteWindow);\n\t\t\t\t\t\t\tif (cb) { cb(remoteWindow); }\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 479');\n\t\t\t\t\t\t\treject(\"util.getFinWindow: Component \" + windowIdentifier.componentType + \" not found.\");\n\t\t\t\t\t\t\tif (cb) { cb(null); }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 484');\n\t\t\t\t\t\t//@TODO, get this through a remote call to Launcher service\n\t\t\t\t\t\treject(\"getFinWindow by componentType is currently only operable within LaunchService\");\n\t\t\t\t\t\tif (cb) { cb(null); }\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tLogger.system.log('Util.getFinWindow - end - 490');\n\t\t\t\t\t// return windowDescriptor for current window\n\t\t\t\t\tif (cb) { cb(myWindow); }\n\t\t\t\t\tresolve(myWindow);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * Retrieves a windowDescriptor given a windowIdentifier\n\t * @param {LauncherClient~windowIdentifier} [windowIdentifier] The window to locate. If empty then the current window is returned.\n\t * @callback {function} cb Function to retrieve result (optional or use Promise)\n\t * @returns {Promise} A promise that resolves to a LauncherClient~windowDescriptor\n\t */\n\tgetWindowDescriptor: function (windowIdentifier, cb) {\n\t\tconsole.debug(\"getWindowDescriptor\");\n\t\tLogger.system.log('Util.getWindowDescriptor - start');\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tLogger.system.log('Util.getWindowDescriptor.getFinWindow - Start');\n\t\t\tmodule.exports.getFinWindow(windowIdentifier).then(function (finWindow) {\n\t\t\t\tLogger.system.log('Util.getWindowDescriptor.getFinWindow - Callback');\n\t\t\t\tLogger.system.log('Util.getWindowDescriptor.getOptions - Start');\n\t\t\t\tfinWindow.getOptions(function (options) {\n\t\t\t\t\tLogger.system.log('Util.getWindowDescriptor.getOptions - Callback');\n\t\t\t\t\tif (cb) { cb(options); }\n\t\t\t\t\tLogger.system.log('Util.getWindowDescriptor - End');\n\t\t\t\t\tresolve(options);\n\t\t\t\t});\n\t\t\t}).catch(function (errorMessage) {\n\t\t\t\tconsole.warn(errorMessage);\n\t\t\t\tLogger.system.log('Util.getWindowDescriptor - End -- Warn');\n\t\t\t\tif (cb) { cb(null); }\n\t\t\t\treject(errorMessage);\n\t\t\t});\n\t\t});\n\t},\n\n\tfindMonitor: function (monitors, field, value) {\n\t\tfor (var i = 0; i < monitors.length; i++) {\n\t\t\tvar monitor = monitors[i];\n\t\t\tif (monitor[field] === value) { return monitor; }\n\t\t}\n\t\treturn null;\n\t},\n\t/**\n\t * @param {number} commandMonitor\n\t * @param {array} monitors\n\t * @param {number} launchingMonitorPosition\n\t * commandMonitor, monitors, launchingMonitorPosition\n\t */\n\tgetWhichMonitor: function (params, cb) {\n\t\t//First release of this method took 3 params.\n\t\tif (arguments.length > 2) {\n\t\t\tparams = {\n\t\t\t\tcommandMonitor: arguments[0],\n\t\t\t\tmonitors: arguments[1],\n\t\t\t\tlaunchingMonitorPosition: arguments[2]\n\t\t\t};\n\t\t\tcb = null;\n\t\t}\n\t\tvar monitor;\n\t\tvar { commandMonitor, monitors, launchingMonitorPosition } = params;\n\t\tvar isANumber = (commandMonitor && commandMonitor !== \"\") || commandMonitor === 0;\n\t\tif (commandMonitor === \"primary\") {\n\t\t\tmonitor = module.exports.findMonitor(monitors, \"whichMonitor\", \"primary\");\n\t\t} else if (commandMonitor === \"next\") {\n\t\t\tlet position = launchingMonitorPosition + 1;\n\t\t\tif (position >= monitors.length) {\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t\tmonitor = monitors[position];\n\t\t} else if (commandMonitor === \"previous\") {\n\t\t\tlet position = launchingMonitorPosition - 1;\n\t\t\tif (position < 0) {\n\t\t\t\tposition = monitors.length - 1;\n\t\t\t}\n\t\t\tmonitor = monitors[position];\n\t\t} else if (commandMonitor === 'mine') {\n\t\t\tvar waiting = true;\n\t\t\tmodule.exports.getFinWindow(params.windowIdentifier).then(function (finWin) {\n\t\t\t\tfinWin.getBounds((bounds) => {\n\t\t\t\t\tmodule.exports.getMonitorFromOpenFinXY(bounds.left, bounds.top, function (monitor) {\n\t\t\t\t\t\tcb(monitor);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t} else if (isANumber) {\n\t\t\tif (commandMonitor >= monitors.length) {\n\t\t\t\tcommandMonitor = monitors.length - 1;\n\t\t\t}\n\t\t\tmonitor = monitors[commandMonitor];\n\t\t} else {\n\t\t\tmonitor = monitors[launchingMonitorPosition];\n\t\t}\n\t\tif (!waiting) {\n\t\t\tif (cb) {\n\t\t\t\tcb(monitor);\n\t\t\t} else {\n\t\t\t\t//maintaining backwards compatibility\n\t\t\t\treturn monitor;\n\t\t\t}\n\t\t}\n\t},\n\n\t/**\n\t * Gets a monitorInfo based on a command. A command is the typical \"monitor\" param\n\t * @param  {string} commandMonitor   Monitor command. See {@link LauncherClient#spawn}\n\t * @param  {object} windowIdentifier The windowIdentifier of the calling function. Necessary to support \"next\",\"previous\" an default.\n\t * @param {function} [cb] Optional callback\n\t * @returns {Promise} A promise that resolves to a monitorInfo\n\t */\n\tgetMonitorFromCommand: function (commandMonitor, windowIdentifier, cb) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tmodule.exports.getMonitor(windowIdentifier, function (monitorInfo) {\n\t\t\t\tmodule.exports.getAllMonitors(function (monitors) {\n\t\t\t\t\tlet params = {\n\t\t\t\t\t\tcommandMonitor: commandMonitor,\n\t\t\t\t\t\tmonitors: monitors,\n\t\t\t\t\t\tlaunchingMonitorPosition: monitorInfo.position\n\t\t\t\t\t};\n\t\t\t\t\tmodule.exports.getWhichMonitor(params, function (finalMonitorInfo) {\n\t\t\t\t\t\tif (cb) { cb(finalMonitorInfo); }\n\t\t\t\t\t\tresolve(finalMonitorInfo);\n\t\t\t\t\t});\n\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * @private\n\t * @param {LauncherClient~windowDescriptor} windowDescriptor\n\t * @param {monitorDimensions} monitorDimensions\n\t * @returns {boolean} Whether window is on the current monitor.\n\t */\n\twindowOnMonitor: function (windowDescriptor, monitorDimensions) {\n\t\t//if right or left edge is within the window's bounds.\n\t\tif ((windowDescriptor.left >= monitorDimensions.left && windowDescriptor.left < monitorDimensions.right) ||\n\t\t\t(windowDescriptor.right <= monitorDimensions.right && windowDescriptor.right > monitorDimensions.left)) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t * Convenience function to get the monitor for the current window\n\t * @param {LauncerClient~windowIdentifier} [windowIdentifier] The window to find the monitor for. Current window if empty.\n\t * @param  {Function} cb Returns a monitor descriptor (optional or use Promise)\n\t * @returns {Promise} A promise that resolves to a monitor descriptor\n\t */\n\tgetMonitor: function (windowIdentifier, cb) {\n\t\treturn new Promise(function (resolve, reject) {\n\t\t\tmodule.exports.getWindowDescriptor(windowIdentifier, function (windowDescriptor) {\n\t\t\t\tif (!windowDescriptor) {\n\t\t\t\t\treject(\"util.getMonitor: Can't locate windowDescriptor.\");\n\t\t\t\t} else {\n\t\t\t\t\tmodule.exports.getMonitorFromWindow(windowDescriptor, function (monitor) {\n\t\t\t\t\t\tif (cb) { cb(monitor); }\n\t\t\t\t\t\tresolve(monitor);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t},\n\t/**\n\t * Returns a windowIdentifier for the current window\n\t * @param {LauncherClient~windowIdentifier} cb Callback function returns windowIdentifier for this window (optional or use Promise)\n\t * @returns {Promise} A promise that resolves to a windowIdentifier\n\t */\n\tgetMyWindowIdentifier: function (cb) {\n\t\tvar finWindow = fin.desktop.Window.getCurrent();\n\t\tLogger.system.log('Util.getMyWindowIdentifier - start');\n\t\treturn new Promise(function (resolve) {\n\t\t\tfinWindow.getOptions((windowDescriptor) => {\n\t\t\t\tvar componentType = null;\n\n\t\t\t\t// Figure out the component type from what was originally stored when we launched the window\n\t\t\t\t// options.customData is where our stuff is found\n\t\t\t\tvar customData = windowDescriptor.customData;\n\t\t\t\tif (customData && customData.component) {\n\t\t\t\t\tcomponentType = customData.component.type;\n\t\t\t\t}\n\t\t\t\tvar windowIdentifier = {\n\t\t\t\t\twindowName: finWindow.name,\n\t\t\t\t\tuuid: finWindow.uuid,\n\t\t\t\t\tcomponentType: componentType\n\t\t\t\t};\n\t\t\t\tLogger.system.log('Util.getMyWindowIdentifier - End');\n\n\t\t\t\tif (cb) { cb(windowIdentifier); }\n\t\t\t\tresolve(windowIdentifier);\n\t\t\t});\n\t\t});\n\t},\n\t/**\n\t *\t@returns {string} Transforms an array of strings into a camelcased string.\n\t * @memberof Utils\n\t */\n\tcamelCase: function () {\n\t\tvar str = '';\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tstr += ' ' + arguments[i];\n\t\t}\n\t\treturn str\n\t\t\t.replace(/\\s(.)/g, function ($1) { return $1.toUpperCase(); })\n\t\t\t.replace(/\\s/g, '')\n\t\t\t.replace(/^(.)/, function ($1) { return $1.toLowerCase(); });\n\t},\n\n\t/**\n\t * Convenience method for cloning an object.\n\t * @param  {any} from The thing you want to copy\n\t * @param {any} to Where you want your copy to end up.\n\t * @return {any} to Where you want your copy to end up.\n\t */\n\tclone: function (from, to) {\n\t\tif (from === null || typeof from !== \"object\") { return from; }\n\t\t// if (from.constructor != Object && from.constructor != Array) return from;\n\t\tif (from.constructor == Date || from.constructor == RegExp || from.constructor == Function ||\n\t\t\tfrom.constructor == String || from.constructor == Number || from.constructor == Boolean) { return new from.constructor(from); }\n\n\t\tto = to || new from.constructor();\n\n\t\tfor (var n in from) {\n\t\t\tto[n] = typeof to[n] === \"undefined\" ? module.exports.clone(from[n], null) : to[n];\n\t\t}\n\n\t\treturn to;\n\t},\n\n\tgetUniqueName: function (baseName) {\n\t\tif (!baseName) {\n\t\t\tbaseName = \"RouterClient\";\n\t\t}\n\t\tvar uuid = baseName + \"-\" + Math.floor(Math.random() * 100) + \"-\" + Math.floor(Math.random() * 10000);\n\t\treturn uuid;\n\t},\n\n\tinjectJS(path, cb) {//Inject a script tag with the path given. Once the script is loaded, it executes the callback.\n\n\t\tvar script = document.createElement('script');\n\t\tscript.onload = cb;\n\t\tscript.type = 'text/javascript';\n\t\tscript.async = true;\n\t\tscript.src = path;\n\t\tvar head = document.getElementsByTagName('head')[0];\n\t\tvar firstScript = head.getElementsByTagName('script')[0];\n\t\thead.insertBefore(script, firstScript);\n\n\t},\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/common/util.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\nvar SystemSettings = require(\"./systemSettings\");\n\n/**\n * @introduction\n * <h2>Finsemble Vaidate Functions</h2>\n * \n */\n\n/**\n * Constructor for Finsemble argment validator.\n *\n * Validatation logic is ONLY RAN when SystemSettings diagnotics level is set to debug (i.e. 4 or above)\n * A failed validation will generate a warning message, but nothing more; however application logic can check the validation results.\n *\n * @param {string} console Finsemble console object used to display messages and check diagnotic level \n * @constructor\n */\t\nvar Validate = function () {\n\n\tfunction warningMsg(paramDescript, thisArg, thisArgType) {\n\n\t\tfunction getErrorObject() {\n\t\t\ttry { throw Error(''); } catch (err) { return err; }\n\t\t}\n\n\t\tvar err = getErrorObject();\n\n\t\tvar caller_line1 = err.stack.split(\"\\n\")[5];\n\t\tvar index1 = caller_line1.indexOf(\"at \");\n\t\tvar msgPart1 = caller_line1.slice(index1 + 2, caller_line1.length);\n\n\t\tvar caller_line2 = err.stack.split(\"\\n\")[6];\n\t\tvar index2 = caller_line2.indexOf(\"at \");\n\t\tvar msgPart2 = caller_line2.slice(index2 + 2, caller_line2.length);\n\n\t\tconsole.warn(\"parameter validation failed: parameter \" + paramDescript + \" is of type '\" + typeof (thisArg) + \"' but should be of type '\" + thisArgType + \"' in\" + msgPart1 + \" called by\" + msgPart2);\n\t}\n\t\n\t/**\n\t * Confirm parameters are valid. A variable number of parameter pairs are supported. \n\t * @param {any} param1 is arg to validate\n\t * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \n\t * @param {any=} param2 is next arg to validate\n\t * @param {string=} paramType2 os required type for next arg \n\t * @return {boolean} returns turn if parameter list is valid; otherwise, false.\n\t *\n\t * @example\n\t *\n\t * var validate = new Validate(console); \n\t * validate.args(name, \"string\", age, \"number\")\n\t *\n\t * validate.args(topic, \"string\", initialState, \"object=\"); // with optional paramter (represented by \"=\")\n\t *\n\t * validate.args(topic, \"string\", initialState, \"any\"); // with \"any\" type\n\t *\n\t * validate.args(subscribeIDStruct, \"object\") && validate.args(subscribeIDStruct.subscribeID, \"string\"); // only do second varidate if first test successful\n\t *\n\t * validate.args(subscribeIDStruct, \"object\", subscribeIDStruct.subscribeID, \"string\"); // only check second parm if first validated successful\n\t *\n\t * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\"); // depending on logic, can break into seperate validations\n\t * params = params || {}; \n\t * validate.args(params.subscribeCallback, \"function=\", params.publishCallback, \"function=\", params.unsubscribeCallback, \"function=\");\n\t */\n\tthis.args = function (param1, paramType1, param2, paramType2 /*.....optional more paramter pairs....*/) {\n\t\tvar returnCode = true;\n\t\tif (SystemSettings.validationEnabled()) {\n\t\t\tvar parmCount = arguments.length;\n\t\t\tif ((parmCount + 1) % 2 !== 0) { // parameters must come in pairs (i.e. even number)\n\t\t\t\tfor (var i = 0; i < parmCount; i = i + 2) {\n\t\t\t\t\tvar optionalArg = false;\n\t\t\t\t\tvar thisArg = arguments[i];\n\t\t\t\t\tvar thisArgType = arguments[i + 1];\n\t\t\t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\n\t\t\t\t\t\tthisArgType = thisArgType.slice(0, -1);\n\t\t\t\t\t\toptionalArg = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\n\t\t\t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\n\t\t\t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\n\t\t\t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\n\t\t\t\t\t\t\t\twarningMsg(parameterPosition, thisArg, thisArgType);\n\t\t\t\t\t\t\t\treturnCode = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"validate.args requires even number of parameters: \" + JSON.stringify(arguments));\n\t\t\t}\n\t\t}\n\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \n\t};\n\n\t/**\n\t * Confirm parameters are valid. args2() has the same functionality as args() except a third \"parameter description\" is passed in for each argument varified\n\t * Typically this for passing in a properties name for better diagnostic messages when varifying object properties.\n\t * A variable number of parameter \"triples\"\" are supported.\n\t *\n\t * @param {string} paramName1 is descriptive name of param1 (for diagnostic message)\n\t * @param {any} param1 is arg to validate\n\t * @param {string} paramType1 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\").\n\t * @param {string} paramName2 is descriptive name of param1 (for diagnostic message)\n\t * @param {any} param2 is arg to validate\n\t * @param {string} paramType2 is required type for parameter (if '=' suffix then parameter is optional). \"any\" represents any type (but not \"undefined\"). \n\t * @return {boolean} returns turn if parameter list is valid; otherwise, false.\n\t *\n\t * @example\n\t *\n\t * var validate = new Utils.Validate(console); \n\t * validate.args2(\"record.name\", record.name, \"string\", \"record.age\", age, \"number\")\n\t *\n\t * // common case using args() and args2() together\n\t * validate.args(topic, \"any\", initialState, \"object=\", params, \"object=\") &&\n\t *   validate.args2(\"params.subscribeCallback\", params.subscribeCallback, \"function=\", \"params.publishCallback\", params.publishCallback, \"function=\") &&\n\t *   validate.args2(\"params.unsubscribeCallback\", params.unsubscribeCallback, \"function=\");\n\t */\n\tthis.args2 = function (paramName1, param1, paramType1, paramName2, param2, paramType2 /*.....optional, more paramter sets of three....*/) {\n\n\t\tvar returnCode = true;\n\t\tif (SystemSettings.validationEnabled()) {\n\t\t\tvar parmCount = arguments.length;\n\t\t\tif ((parmCount + 1) % 3 !== 0) { // parameters must come in sets of three \n\t\t\t\tfor (var i = 0; i < parmCount; i = i + 3) {\n\t\t\t\t\tvar optionalArg = false;\n\t\t\t\t\tvar thisArgName = arguments[i];\n\t\t\t\t\tvar thisArg = arguments[i + 1];\n\t\t\t\t\tvar thisArgType = arguments[i + 2];\n\t\t\t\t\tif (thisArgType.slice(-1) === \"=\") { // if last char is \"=\" then optional argument\n\t\t\t\t\t\tthisArgType = thisArgType.slice(0, -1);\n\t\t\t\t\t\toptionalArg = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof (thisArg) !== thisArgType) { // confirms basic case -- the required type\n\t\t\t\t\t\tif (!optionalArg || typeof (thisArg) !== \"undefined\") { // but optional parms can be undefined\n\t\t\t\t\t\t\tif (typeof (thisArg) === \"undefined\" || thisArgType !== \"any\") { // but \"any\" type doesn't have to match but can't be undefined\n\t\t\t\t\t\t\t\tvar parameterPosition = (i / 2) + 1;\n\t\t\t\t\t\t\t\twarningMsg(thisArgName, thisArg, thisArgType);\n\t\t\t\t\t\t\t\treturnCode = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn(\"validate.args requires even number of parameters: \" + JSON.stringify(arguments));\n\t\t\t}\n\t\t}\n\t\treturn returnCode; // always return turn when validation is disable due debug lebel turned off \n\t};\n};\n\nmodule.exports = new Validate();\n\n\n// WEBPACK FOOTER //\n// ./src/common/validate.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n/**\n * @introduction\n * <h2>Router Client Instance</h2>\n * Exports a single shared instance of the router client.  See {@link RouterClientConstructor} for the complete API definition with examples.\n *\n * Example:\n *\n *\t// get a shared instance of RouterClient (shared within the containing component or service)\n *\tvar RouterClient = require('./routerClientInstance');\n *\n * @namespace routerClientInstance\n * @shouldBePublished false\n */\n\n\"use strict\";\n\nvar RouterClientConstructor = require(\"./routerClientConstructor\");\n\nmodule.exports = new RouterClientConstructor({ clientName: \"RouterClient\" });\n\n\n// WEBPACK FOOTER //\n// ./src/clients/routerClientInstance.js","var RouterClient, thisApp, Logger;\n/**\n * This file receives SpawnRequests from a master `SplinterAgent`.\n */\nfin.desktop.main(function () {\n\tRouterClient = require(\"../../clients/routerClientInstance\");\n\tLogger = require(\"../../clients/logger\");\n\tLogger.start();\n\tthisApp = fin.desktop.Application.getCurrent();\n\tRouterClient.ready(onRouterReady);\n});\n\nfunction onSetTitle(err, message) {\n\tdocument.title = message.data.title;\n}\nfunction onRouterReady() {\n\tLogger.system.verbose(\"SpltinerAgentSlave ready.\");\n\tRouterClient.addListener(`${thisApp.uuid}.spawn`, onSpawnRequest);\n\tRouterClient.addListener(`${thisApp.uuid}.setTitle`, onSetTitle);\n\tRouterClient.transmit(`${thisApp.window.name}.onSpawned`, {});\n}\n\nfunction onSpawnRequest(err, message) {\n\tLogger.system.verbose(\"SpltinerAgentSlave.onSpawnRequest.\", message.data.windowDescriptor);\n\tlet descriptor = message.data.windowDescriptor;\n\tif (!descriptor) {\n\t\tLogger.system.error(\"SplinterAgentSlave.onSpawnRequest ERROR: No windowDescriptor\", message);\n\t\treturn;\n\t}\n\tlet finWin = new fin.desktop.Window(descriptor, function () {\n\t\tLogger.system.verbose(`SplinterAgentSlave.onSpawnRequest: Window successfully spawned. WindowName: ${descriptor.name}`);\n\t}, function (err) {\n\t\tLogger.system.error(\"SplinterAgentSlave.onSpawnRequest ERROR\", err);\n\t});\n}\n\n\n// WEBPACK FOOTER //\n// ./src/services/launcher/SplinterAgentSlave.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\n/**\n * @introduction\n * <h2>Finsemble system wide settings for use by all components and services</h2>\n *\n */\n\n/**\n * Constructor for Finsemble SystemSettings\n * @private\n * @constructor\n */\nvar SystemSettings = function () {\n\tvar currentDiagLevel = 3;\n\n\t/**\n\t * Returns diagnostic level\n\t *\n\t *@returns current diagnostic level\n\t */\n\tthis.diagLevel = function () {\n\t\treturn currentDiagLevel;\n\t};\n\n\t/**\n\t * Returns diagnostic level\n\t *\n\t *@returns current diagnostic level\n\t */\n\tthis.setDiagLevel = function (level) {\n\t\tcurrentDiagLevel = level;\n\t};\n\n\t/**\n\t * Returns true if parameter validation is enabled\n\t *\n\t *@returns true if enable\n\t */\n\tthis.validationEnabled = function () {\n\t\treturn (currentDiagLevel >= 4);\n\t};\n};\n\nmodule.exports = new SystemSettings();\n\n\n// WEBPACK FOOTER //\n// ./src/common/systemSettings.js","/*!\n* Copyright 2017 by ChartIQ, Inc.\n* All rights reserved.\n*/\n\nvar FSBLUtils = require(\"./util\");\nvar Logger = require(\"../clients/logger\");\n\nvar ConfigUtil = {\n\t/**\n\t * @introduction\n\t * <h2>Finsemble Configuration Utility Functions</h2>\n\t * @private\n\t * @class ConfigUtil\n\t */\n\t// run through the configuration object and resolve any variables definitions (i.e. $applicationRoot)\n\tresolveConfigVariables(finsembleConfig, startingConfigObject) {\n\t\tvar pass = 0;\n\t\tvar needsAnotherPass = true;\n\n\t\t// resolve a variable within a config string\n\t\tfunction resolveString(configString) {\n\t\t\tvar seperators = /[/\\\\:?=&]/; // list of seperators in regex form (will add other seperators if needed)\n\t\t\tvar tokens = configString.split(seperators);\n\t\t\tfor (var i = 0; i < tokens.length; i++) {\n\t\t\t\tif (tokens[i][0] === \"$\") { // special variable character $ has to first char in string\n\t\t\t\t\tvar variableReference = tokens[i].substring(1); // string off the leading $\n\t\t\t\t\tvar variableResolution = finsembleConfig[variableReference]; // the variable value is another config property, which already must be set\n\t\t\t\t\tvar newValue = configString.replace(tokens[i], variableResolution); // replace the variable reference with new value\n\t\t\t\t\tLogger.system.verbose(\"resolveString configString\", tokens[i], variableReference, variableResolution, \"oldvalue=\", configString, \"value=\", newValue);\n\t\t\t\t\tneedsAnotherPass = true; // <<-- here is the only place needsAnotherPass is set, since still resolving variables\n\t\t\t\t\tconfigString = newValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn (configString);\n\t\t}\n\n\t\t// process an array of config items looking for variables to resolve (a recursive routine)\n\t\tfunction resolveArray(configArray, pass, recursionLevel) {\n\t\t\tLogger.system.verbose(\"resolveArray\", \"pass\", pass, \"recursionLevel\", recursionLevel, \"configArray:\", configArray);\n\t\t\tfor (var i = 0; i < configArray.length; i++) {\n\t\t\t\tvar value = configArray[i];\n\t\t\t\tif (typeof (value) === \"string\" && value.indexOf(\"$\") > -1) {\n\t\t\t\t\tconfigArray[i] = resolveString(value);\n\t\t\t\t} else if (value instanceof Array) {\n\t\t\t\t\tresolveArray(value, pass, recursionLevel + 1); // array reference passed so don't need return value\n\t\t\t\t} else if (typeof (value) === \"object\") {\n\t\t\t\t\tresolveObject(value, pass, recursionLevel + 1); // object reference passed so don't need return value\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// process an object of config properties looking for variables to resolve (a recursive routine)\n\t\tfunction resolveObject(configObject, pass, recursionLevel) {\n\t\t\tLogger.system.verbose(\"resolveObject\", \"pass\", pass, \"recursionLevel\", recursionLevel, \"configObject:\", configObject);\n\t\t\tObject.keys(configObject).forEach(function (key) {\n\t\t\t\tvar value = configObject[key];\n\t\t\t\tif (typeof (value) === \"string\" && value.indexOf(\"$\") > -1) {\n\t\t\t\t\tconfigObject[key] = resolveString(value);\n\t\t\t\t} else if (value instanceof Array) {\n\t\t\t\t\tresolveArray(value, pass, recursionLevel + 1); // array reference passed so don't need return value\n\t\t\t\t} else if (typeof (value) === \"object\") {\n\t\t\t\t\tresolveObject(value, pass, recursionLevel + 1); // object reference passed so don't need return value\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// since variables may be nested, keep resolving till no more left\n\t\twhile (needsAnotherPass) {\n\t\t\tneedsAnotherPass = false; // don't need another pass afterwards unless a variable is resolved somewhere in finsembleConfig\n\t\t\tresolveObject(startingConfigObject, ++pass, 1);\n\t\t}\n\t},\n\n\t// This does mimimal processing of the manifest, just enough to support getting the router up, which is only expanding variables (e.g. moduleRoot) in the raw manifest\n\tgetExpandedRawManifest(callback) {\n\t\tLogger.system.debug(\"getExpandedRawManifest starting\");\n\n\t\tfunction getRawManifest(callback, application, level) {\n\t\t\tLogger.system.debug(\"getRawManifest\", application, level);\n\n\n\t\t\tapplication.getManifest(function (manifest) { // get raw openfin manifest\n\t\t\t\tLogger.system.debug(\"getExpandedRawManifest manifest\", manifest);\n\n\t\t\t\tConfigUtil.resolveConfigVariables(manifest.finsemble, manifest.finsemble); // resolve variables first time so can fild config config location\n\t\t\t\tLogger.system.debug(\"getExpandedRawManifest Complete\", manifest);\n\t\t\t\tcallback(manifest);\n\t\t\t}, function (err) {\n\t\t\t\tLogger.system.debug(\"getExpandedRawManifest err\", err);\n\t\t\t\t// no manifest so try parent\n\t\t\t\tapplication.getParentUuid(function (parentUuid) {\n\t\t\t\t\tvar parentApplication = fin.desktop.Application.wrap(parentUuid);\n\t\t\t\t\tLogger.system.debug(\"uuid\", parentUuid, \"parentApplication\", parentApplication);\n\t\t\t\t\tif (level < 10) {\n\t\t\t\t\t\tgetRawManifest(callback, parentApplication, ++level);\n\t\t\t\t\t} else { // still could find so must be a problem (i.e. avoid infinite loop)\n\t\t\t\t\t\tcallback(\"could not find manifest in parent applications\");\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\tfin.desktop.main(function () { // make sure openfin is ready\n\t\t\tvar application = fin.desktop.Application.getCurrent();\n\t\t\tgetRawManifest(callback, application, 1);\n\t\t});\n\t},\n\n\t// This does a \"first stage\" processing of the manifest, providing enought config to start finsemble.\n\t// Pull in the initial manifest, which includes gettig the \"hiddlen\" core config file along with its import definitions, and expand all variables.\n\t// However, the full config processing, incluing actually doing the imports, is only done in the Config Service.\n\tgetInitialManifest(callback) {\n\t\tvar CORE_CONFIG; // will hold location of core config file\n\n\t\t// async read of JSON config file\n\t\tfunction getCoreConfig(coreConfigFile, importCallback) {\n\t\t\tLogger.system.debug(\"fetching \" + coreConfigFile);\n\t\t\tfetch(coreConfigFile, {\n\t\t\t\tcredentials: \"include\"\n\t\t\t}).then(function (response) {\n\t\t\t\treturn response.json();\n\t\t\t}).catch(function (err) {\n\t\t\t\timportCallback(\"failure importing \" + err, null);\n\t\t\t}).then(function (importObject) {\n\t\t\t\timportCallback(null, importObject);\n\t\t\t});\n\t\t}\n\n\t\tfin.desktop.main(function () { // make sure openfin is ready\n\t\t\tvar application = fin.desktop.Application.getCurrent();\n\t\t\tapplication.getManifest(function (manifest) { // get raw openfin manifest\n\t\t\t\tConfigUtil.resolveConfigVariables(manifest.finsemble, manifest.finsemble); // resolve variables first time so can fild config config location\n\t\t\t\tvar CORE_CONFIG = manifest.finsemble.moduleRoot + \"/configs/core/config.json\"; // <<<--- here is the \"hidden\" core config file\n\t\t\t\tgetCoreConfig(CORE_CONFIG, function (error, newFinsembleConfigObject) { // fetch the core config file\n\t\t\t\t\tif (!error) {\n\t\t\t\t\t\tObject.keys(newFinsembleConfigObject).forEach(function (key) {\n\t\t\t\t\t\t\tif (key === \"importConfig\") {\n\t\t\t\t\t\t\t\t// add any importConfig items from the core to the existing importConifg\n\t\t\t\t\t\t\t\tmanifest.finsemble.importConfig = manifest.finsemble.importConfig || [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < newFinsembleConfigObject.importConfig.length; i++) {\n\t\t\t\t\t\t\t\t\tmanifest.finsemble.importConfig.unshift(newFinsembleConfigObject.importConfig[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (key === \"importThirdPartyConfig\") {\n\t\t\t\t\t\t\t\t// add any importThirdPartyConfig items from the core to the existing importConifg\n\t\t\t\t\t\t\t\tmanifest.finsemble.importThirdPartyConfig = manifest.finsemble.importThirdPartyConfig || [];\n\t\t\t\t\t\t\t\tfor (var i = 0; i < newFinsembleConfigObject.importThirdPartyConfig.length; i++) {\n\t\t\t\t\t\t\t\t\tmanifest.finsemble.importThirdPartyConfig.unshift(newFinsembleConfigObject.importThirdPartyConfig[i]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmanifest.finsemble[key] = newFinsembleConfigObject[key];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tConfigUtil.resolveConfigVariables(manifest.finsemble, manifest.finsemble); // resolve variables with finsemble config\n\t\t\t\t\t\tLogger.system.debug(\"Initial Manifest after variables Resolved\", manifest);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tLogger.system.error(\"failed importing into finsemble config\", currentImportURL, error);\n\t\t\t\t\t}\n\t\t\t\t\tcallback(manifest);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n};\n\nmodule.exports = ConfigUtil;\n\n\n// WEBPACK FOOTER //\n// ./src/common/configUtil.js"],"mappings":";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;A;;;;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvLA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACphBA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlHA;AACA;AAoHA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC9RA;;;;;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AA8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxrCA;;;;AAIA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA9tBA;AACA;;;;;;;;;ACPA;;;;AAIA;AACA;AACA;;;;;;AAMA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AC5JA;;;;;AAKA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACxBA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACnCA;;;;;AAKA;;;;;;AAMA;;;;;AAKA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChDA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1JA;AACA;AA4JA;AACA;;;;;;A","sourceRoot":""}